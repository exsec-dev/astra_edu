import ReviewBlock from './ReviewBlock';
import like from '../../../icons/robocat/like.webp';
import tongue from '../../../icons/robocat/tongue.webp';
import think from '../../../icons/robocat/think.webp';
import cheers from '../../../icons/robocat/cheers.webp';
import smile from '../../../icons/robocat/smile.webp';
import Title from './Title';
import Subtitle from './Subtitle';
import CustomTable from './CustomTable';
import List from './List';
import Replica from './Replica';
import InfoBlock from './InfoBlock';
import Paragraph from './Paragraph';
import CodeBlock from './CodeBlock';

export const commandlineData = [
    {
        chapter: 'Интерфейс командной строки',
        content: [
            {
                component: Title,
                text: 'Командная строка в Linux',
            },
            {
                component: Paragraph,
                text: 'Замечали ли вы когда-нибудь, что в фильмах, когда «суперхакер» — гений, способный за 30 секунд взломать суперзащищенную систему, — садится за компьютер, он никогда не берется за мышь? Создатели таких фильмов инстинктивно понимают, что мы можем сделать за компьютером что-то действительно стоящее, только вводя команды с клавиатуры. И это даже не является заблуждением!',
            },
            {
                component: Paragraph,
                text: 'Большинство современных пользователей компьютеров знакомы только с графическим интерфейсом Graphical User Interface, GUI и полагают, что интерфейс командной строки Command Line Interface, CLI — это древний мир. На самом деле, интерфейс командной строки — это удобный и выразительный способ общения с компьютером, во многом напоминающий способ письменного общения между людьми. Как однажды было подмечено, «графический пользовательский интерфейс делает простые задачи еще проще, а интерфейс командной строки делает сложные задачи выполнимыми», — это высказывание остается истинным и по сей день.',
            },
            {
                component: Paragraph,
                text: 'Поскольку операционная система Linux создавалась на основе семейства операционных систем Unix, она унаследовала богатое разнообразие инструментов командной строки Unix. ОС Unix заняла ведущее положение в начале 1980-х, еще до повсеместного распространения графического интерфейса, и широко использовала интерфейс командной строки. Одной из основных причин, по которой первопроходцы Linux выбрали эту ОС, была мощная поддержка интерфейса командной строки, который «делает сложные задачи выполнимыми».',
            },
            {
                component: Title,
                text: 'Первый запуск',
            },
            {
                component: Paragraph,
                text: 'Говоря о командной строке, на самом деле мы имеем в виду командную оболочку <shell>. Командная оболочка — это программа, которая принимает команды, введенные с клавиатуры, и передает их операционной системе для выполнения. Практически все дистрибутивы Linux, в том числе и Astra Linux, поставляются с командной оболочкой из проекта GNU, которая называется <bash>.',
            },
            {
                component: InfoBlock,
                text: 'Имя bash — это аббревиатура от названия Bourne Again Shell, отражающего тот факт, что bash является улучшенной заменой sh, первоначальной командной оболочки для Unix, написанной Стивом Борном.',
            },
            {
                component: Paragraph,
                text: 'При использовании графического интерфейса для взаимодействия с командной оболочкой в Astra Linux нам понадобится приложение Терминал Fly. Это эмулятор консоли, предоставляющий доступ к командной оболочке.',
            },
            {
                component: InfoBlock,
                text: 'Всегда можно переключиться из графического режима непосредственно в консоль Linux, нажав Ctrl+Alt+F1, однако для большинства пользователей будет удобнее работа в графическом режиме.',
            },
            {
                component: Paragraph,
                text: 'Итак, приступим. Запустите эмулятор терминала. После появления окна на экране вы увидите в нем нечто подобное:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$!',
            },
            {
                component: Paragraph,
                text: 'Не пугайтесь, это не код ошибки или секретное сообщение от хакеров. Это называется приглашением к вводу <shell prompt> и появляется всякий раз, когда командная оболочка готова принять ввод. В Astra Linux приглашение включает строку <имя_пользователя@имя_компьютера>, за которой следует имя текущего каталога (подробнее об этом позже) и знак доллара. Если последний символ в приглашении — знак решетки <#>, а не знак доллара <$>, это означает, что сеанс в терминале обладает привилегиями суперпользователя.',
            },
            {
                component: Replica,
                image: smile,
                text: 'Суперпользователь в Linux — это самый могущественный и опасный пользователь в системе. Он может делать все, что захочет, без каких-либо ограничений и разрешений.',
                isRight: false,
                align: 'flex-end',
            },
            {
                component: Paragraph,
                text: 'Будем считать, что пока все идет хорошо, и попробуем что-нибудь ввести. Наберите на клавиатуре какую-нибудь бессмыслицу, например:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! abcd',
                canCopy: true
            },
            {
                component: Paragraph,
                text: 'Поскольку это бессмыслица, командная оболочка немедленно сообщит об этом и даст вам второй шанс:',
            },
            {
                component: CodeBlock,
                text: 'bash: abcd: команда не найдена\n!robocat@astra:~$!',
            },
            {
                component: Title,
                text: 'История команд',
            },
            {
                component: Paragraph,
                text: 'Если теперь нажать клавишу со стрелкой вверх, после приглашения к вводу появится предыдущая команда <abcd>. Это называется историей команд. Linux по умолчанию запоминает последние 1000 команд. Нажмите клавишу со стрелкой вниз, и предыдущая команда исчезнет.',
            },
            {
                component: Title,
                text: 'Управление курсором',
            },
            {
                component: Paragraph,
                text: 'Вызовите предыдущую команду, еще раз нажав клавишу со стрелкой вверх. Теперь попробуйте понажимать клавиши со стрелками влево и вправо. Видите, как меняется позиция курсора в командной строке? Благодаря этому легко можно редактировать команды.',
            },
            {
                component: Title,
                text: 'Некоторые простые команды',
            },
            {
                component: Paragraph,
                text: 'Теперь, когда мы понажимали клавиши, попробуем ввести несколько простых команд. Первая команда <date>. Она выводит текущие время и дату:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! date\nВт янв 23 22:47:04 MSK 2024',
                canCopy: true
            },
            {
                component: Paragraph,
                text: 'Родственная ей команда <cal> по умолчанию выводит календарь текущего месяца:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! cal\nЯнварь 2024\nВс Пн Вт Ср Чт Пт Сб\n    1  2  3  4  5  6\n 7  8  9 10 11 12 13\n14 15 16 17 18 19 20\n21 22 23 24 25 26 27\n28 29 30 31',
                canCopy: true
            },
            {
                component: Paragraph,
                text: 'В отличие от предыдущей команды, команда <cal> имеет сокращенное название (от слова calendar). Такие сокращения от слов используются во множестве команд для удобства их быстрого ввода. Некоторые команды представляют собой целые аббревиатуры. Например, команда <pwd> (print working directory) – печатает текущий рабочий каталог на случай, если вы вдруг потерялись.',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! pwd\n/home/robocat',
                canCopy: true
            },
            {
                component: Paragraph,
                text: 'Команда <ps> (process status) – показывает информацию о запущенных процессах.',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! ps\n PID TTY          TIME CMD\n1026 pts/0    00:00:00 bash\n2044 pts/0    00:00:00 ps',
                canCopy: true
            },
            {
                component: Paragraph,
                text: 'Эта команда используется для просмотра списка текущих процессов в виде таблицы, с которой можно удобно работать: сортировать, изменять количество колонок и прочие, которые мы рассмотрим в других уроках.',
            },
            {
                component: Paragraph,
                text: 'В выводе команды ps представлены следующие столбцы:',
            },
            {
                component: List,
                list: ['PID: идентификатор процесса', 'TTY: терминал, на котором запущен процесс', 'TIME: время, затраченное процессом на выполнение', 'CMD: команда, запустившая процесс'],
            },
            {
                component: Paragraph,
                text: 'В нашем случае вывод команды ps показывает два процесса:',
            },
            {
                component: List,
                list: ['«bash» с идентификатором 1026, который запущен на текущем терминале «pts/0»', '«ps», представляющий саму команду, с идентификатором 2044, который также запущен на этом терминале'],
            },
            {
                component: Paragraph,
                text: 'Другой интересной командой является <echo>, которая выводит на экран заданную строку или значение переменной. Попробуйте записать следующее:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! echo "Привет!"',
                canCopy: true
            },
            {
                component: Paragraph,
                text: 'Командная строка приветствует нас в ответ! Но, к сожалению, <echo> будет выводить всегда лишь заданные пользователем строки или значения переменных, которые мы рассмотрим позже.',
            },
            {
                component: Paragraph,
                text: 'Существует и другой способ «общения» с системой. Команда <whoami> выведет на экран имя текущего пользователя, то есть то, как вы представились системе.',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! whoami\nrobocat',
                canCopy: true
            },
            {
                component: Paragraph,
                text: 'Сейчас мы авторизованы под именем Котобота. Эта команда чаще всего используется для проверки, под каким пользователем выполняется сценарий или команда.',
            },
            {
                component: Title,
                text: 'Автодополнение',
            },
            {
                component: Paragraph,
                text: 'Linux содержит множество команд. Если вы забыли точное название команды или просто хотите ускорить ее ввод, вы можете использовать автодополнение командной строки. Для этого введите первые буквы названия команды и нажмите клавишу <Таb>. Далее система автоматически дополнит команду или выведет список доступных вариантов.',
            },
            {
                component: Replica,
                image: like,
                isRight: true,
                align: 'flex-start',
                text: 'Попробуй вписать в командную строку первые две буквы команды pwd и нажать Tab. Быстро и удобно, не так ли? Система будто понимает нас с полуслова!',
            },
            {
                component: Title,
                text: 'Завершение сеанса',
            },
            {
                component: Paragraph,
                text: 'Прежде чем завершить работу с командной строкой, снова посмотрим на экран терминала. Ранее мы вводили множество различных команд, и система всегда выдавала нам свой ответ. Именно поэтому сейчас на экране так много разных символов. С помощью команды <clear> мы можем придать терминалу его первоначальный вид, очистив все содержимое.',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! clear',
                canCopy: true
            },
            {
                component: Paragraph,
                text: 'Не переживайте, ранее введенные команды все еще можно будет найти в истории команд. Историю можно посмотреть не только нажимая клавишу со стрелкой вверх, но и с помощью специальной команды <history>.',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! history\n1  absd\n2  date\n3  cal\n4  pwd\n5  ps\n6  echo "Привет!"\n7  whoami\n8  clear\n9  history',
                canCopy: true
            },
            {
                component: Paragraph,
                text: 'Теперь завершим сеанс работы с терминалом, либо закрыв окно эмулятора терминала, либо введя команду <exit>:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! exit',
                canCopy: true
            },
        ],
        tests: [
            {
                name: "#1    Чем отличается эмулятор консоли от командной оболочки?",
                answers: [
                    "Эмулятор консоли создает среду терминала, а командная оболочка интерпретирует команды",
                    "Эмулятор консоли и командная оболочка — это одно и то же",
                    "Эмулятор консоли запускает программы, а командная оболочка обрабатывает ввод",
                    "Эмулятор консоли является физическим устройством"
                ],
                correct: "A",
            },
            {
                name: "#2    Из каких частей состоит shell prompt?",
                answers: [
                    "имя_пользователя@имя_компьютера:рабочий_каталог",
                    "имя_пользователя@имя_компьютера:корень_файловой_системы",
                    "имя_компьютера@имя_пользователя:рабочий_каталог",
                    "имя_пользователя@пароль_пользователя:рабочий_каталог"
                ],
                correct: "A",
            },
            {
                name: "#3    Что означает знак решетки # в приглашении ко вводу?",
                answers: [
                    "Работа в графическом режиме",
                    "Неформатированный ввод",
                    "Пользователь имеет расширенные права администрирования",
                    "Пользователь имеет ограниченные права администрирования"
                ],
                correct: "C",
            },
            {
                name: "#4    Что делает команда echo?",
                answers: [
                    "Открывает новый терминал",
                    "Выводит текстовые данные на стандартный вывод",
                    "Создает копию файла",
                    "Перемещает пользователя в домашний каталог"
                ],
                correct: "B",
            },
            {
                name: "#5    Какими средствами можно увидеть ранее введенные команды?",
                answers: [
                    "Только при помощи команды history",
                    "Нажимать TAB",
                    "Использовать клавиши со стрелками, а также команду history",
                    "Использовать команду previous"
                ],
                correct: "C",
            },
        ],
        conclusion: [
            {
                component: Title,
                text: 'Итого',
            },
            {
                component: Paragraph,
                text: 'Поздравляем с завершением первого урока! Сегодня мы только начали наше путешествие по командной строке Astra Linux, узнали, что такое командная оболочка, как запустить и завершить сеанс работы с терминалом. Мы также увидели работу нескольких простых команд и узнали, как выполняются простейшие операции редактирования в командной строке.',
            },
            {
                component: Replica,
                image: like,
                text: 'Это было совсем не страшно, правда? Конечно, в начале обучения командная строка может показаться сложной, но не переживай! Со временем мы освоим основные команды и синтаксис, и она перестанет казаться неведомым зверем. На самом деле, она может быть даже веселой и дружелюбной, если знать, как с ней общаться.',
                isRight: false,
                align: 'flex-end',
            },
        ],
    },
    {
        chapter: 'Навигация',
        content: [
            {
                component: Title,
                text: 'Дерево каталогов',
            },
            {
                component: Paragraph,
                text: 'Так же как Windows, Unix-подобная операционная система, такая как Linux, организует свои файлы в иерархическую структуру каталогов. То есть каталоги (в других системах их иногда называют папками) имеют древовидную организацию и могут содержать файлы и другие каталоги. Первый каталог в файловой системе называется корневым каталогом. Корневой каталог содержит файлы и подкаталоги, которые в свою очередь также содержат файлы и каталоги, и т. д.',
            },
            {
                component: Paragraph,
                text: 'Обратите внимание, что в отличие от Windows, где для каждого устройства хранения создается отдельная файловая система, в Unix-подобных системах, таких как Linux, всегда имеется только одна файловая система, независимо от числа приводов или устройств хранения, подключенных к компьютеру. Устройства хранения подключаются (или, как принято говорить, монтируются) к разным точкам дерева в соответствии с желанием системного администратора, человека (или нескольких человек), ответственного за обслуживание системы.',
            },
            {
                component: Title,
                text: 'Текущий рабочий каталог',
            },
            {
                component: Paragraph,
                text: 'Наверняка вы знакомы с графическими диспетчерами файлов, представляющими дерево каталогов файловой системы. Astra Linux, аналогично другим системам, также имеет представление файловой системы в графическом интерфейсе – приложение «Менеджер файлов».',
            },
            {
                component: Paragraph,
                text: 'Командная строка в свою очередь не имеет графического интерфейса, поэтому для перемещения по дереву файловой системы его следует представлять иначе.',
            },
            {
                component: Paragraph,
                text: 'Представьте файловую систему в виде лабиринта в форме перевернутого дерева и себя в середине. В любой конкретный момент времени мы можем находиться только в одном каталоге, видеть файлы в этом каталоге и перемещаться в вышележащий каталог (называется родительским каталогом) и в любые нижележащие каталоги. Каталог, в котором мы находимся, называется текущим рабочим каталогом. Как уже упоминалось ранее, название текущего рабочего каталога выводится командой <pwd> (print working directory — вывести рабочий каталог).',
            },
            {
                component: Paragraph,
                text: 'Сразу после входа в систему (или запуска сеанса в эмуляторе терминала) текущим рабочим каталогом становится наш домашний каталог. Каждый пользователь имеет свой домашний каталог, который является единственным, где пользователю позволено осуществлять запись в файлы, когда он действует с привилегиями обычного пользователя.',
            },
            {
                component: Title,
                text: 'Вывод содержимого каталога',
            },
            {
                component: Paragraph,
                text: 'Познакомимся с командой <ls> (list directory), которая выведет на экран список файлов и подкаталогов внутри текущего рабочего каталога.',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! ls\n<lb>Desktop</lb>   <lb>SystemWallpapers</lb>  <b>Документы</b>  <b>Изображения</b>  <b>Общедоступные</b>\n<b>Desktops</b>  <b>Видео</b>             <b>Загрузки</b>   <b>Музыка</b>       <b>Шаблоны</b>',
                canCopy: true
            },
            {
                component: Paragraph,
                text: 'Здесь в первый раз мы видим использование цветов в выводе команды. В нашем случае цвета означают типы элементов в текущем каталоге: голубой означает символическую ссылку, а синий – каталог.',
            },
            {
                component: Paragraph,
                text: 'В действительности командой <ls> можно вывести содержимое любого, не только текущего каталога, а также получить массу дополнительной любопытной информации, но об этом мы поговорим в главе, посвященной файловой системе Linux.',
            },
            {
                component: Title,
                text: 'Смена каталога',
            },
            {
                component: Paragraph,
                text: 'Чтобы сменить рабочий каталог (в котором мы находимся в середине лабиринта), можно воспользоваться командой <cd>, добавив к ней путь к желаемому рабочему каталогу. Путь (<pathname>) — это маршрут, перечисляющий ветви дерева, по которым нужно пройти, чтобы достигнуть желаемого каталога. Пути могут определяться двумя способами: как абсолютные или как относительные. Поговорим сначала про абсолютные пути.',
            },
            {
                component: Title,
                text: 'Абсолютные пути',
            },
            {
                component: Paragraph,
                text: 'Абсолютный путь начинается с корневого каталога и перечисляет ветви дерева, отделяющие корень от желаемого каталога или файла. Например, в системе имеется каталог, в который устанавливается большинство программ. Путь к этому каталогу имеет вид </usr/bin>. То есть в корневом каталоге (представлен первым символом </>) имеется каталог с названием <usr>, содержащий каталог с названием <bin>.',
            },
            {
                component: Replica,
                image: smile,
                isRight: false,
                align: 'flex-end',
                text: 'Абсолютный путь – это как полный адрес. Например, как тот, что был указан на почтовой посылке со мной. Обычно он начинается со страны, дальше идет название области или региона, потом города, улицы, дома и квартиры!',
            },
            {
                component: Paragraph,
                text: 'Воспользуемся новой командой <cd> и перейдем в каталог </usr/bin>.',
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: '!robocat@astra:~$! pwd\n/home/robocat\n!robocat@astra:~$! cd /usr/bin\n!robocat@astra:/usr/bin$! pwd\n/usr/bin',
            },
            {
                component: Paragraph,
                text: 'Обратите внимание, как изменилось приглашение командной оболочки к вводу после перехода в каталог </usr/bin>. Для удобства оно обычно настраивается так, чтобы автоматически показывать название рабочего каталога.',
            },
            {
                component: Title,
                text: 'Относительные пути',
            },
            {
                component: Paragraph,
                text: 'В отличие от абсолютного пути, начинающегося в корневом каталоге и ведущего к каталогу назначения, относительный путь начинается в рабочем каталоге. Для обозначения относительных позиций в дереве файловой системы используется пара специальных символов: <.> (точка) и <..> (точка-точка).',
            },
            {
                component: Paragraph,
                text: 'Символ <.> (точка) обозначает рабочий каталог, а символ <..> (точка-точка) обозначает каталог, родительский по отношению к рабочему. Давайте попробуем сменить рабочий каталог на родительский для каталога </usr/bin>, которым является </usr>. Сделать это можно двумя способами:',
            },
            {
                component: List,
                list: ['Использовать абсолютный путь:'],
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: '!robocat@astra:/usr/bin$! cd /usr\n!robocat@astra:/usr$! pwd\n/usr',
            },
            {
                component: List,
                list: ['Использовать относительный путь:'],
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: '!robocat@astra:/usr/bin$! cd ..\n!robocat@astra:/usr$! pwd\n/usr',
            },
            {
                component: Paragraph,
                text: 'Два разных способа дают идентичные результаты. И каким же лучше пользоваться? Конечно, тем, который требует нажимать меньше клавиш!',
            },
            {
                component: Paragraph,
                text: 'Аналогично, существуют два способа сменить рабочий каталог с </usr> на </usr/bin>.',
            },
            {
                component: List,
                list: ['Указать абсолютный путь:'],
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: '!robocat@astra:/usr$! cd ./bin\n!robocat@astra:/usr/bin$! pwd\n/usr/bin',
            },
            {
                component: List,
                list: ['Или относительный:'],
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: '!robocat@astra:/usr$! cd /usr/bin\n!robocat@astra:/usr/bin$! pwd\n/usr/bin',
            },
            {
                component: Replica,
                isRight: false,
                align: 'flex-end',
                image: think,
                text: 'А относительный путь можно представить как сокращенную запись адреса. Ведь когда мы находимся в каком-либо городе (текущий каталог), нам не нужно называть полный адрес. Достаточно назвать лишь улицу и дом, чтобы вас поняли.',
            },
            {
                component: InfoBlock,
                text: 'Здесь следует сделать важное замечание. Практически во всех случаях можно опустить написание символов ./, так как они подразумеваются по умолчанию. Если путь к чему-либо не указан явно, подразумевается текущий рабочий каталог.',
            },
            {
                component: Title,
                text: 'Полезные сокращения',
            },
            {
                component: Paragraph,
                text: 'В этой таблице перечислены некоторые способы быстрой смены рабочего каталога.',
            },
            {
                component: CustomTable,
                data: [
                    ['Сокращение', 'Результат'],
                    ['cd', 'Сменить рабочий каталог на домашний'],
                    ['cd -', 'Сменить рабочий каталог на предыдущий рабочий каталог'],
                    ['cd ~', 'Сменить рабочий каталог на домашний каталог пользователя username. Например, cd ~user1 выполнит переход в домашний каталог пользователя user1'],
                ],
            },
        ],
        tests: [
            {
                name: "#1    Какой каталог является рабочим сразу после входа в систему?",
                answers: [
                    "/ (корневой каталог)",
                    "/home (каталог пользователей)",
                    "/tmp (временный каталог)",
                    "/home/имя_пользователя (домашний каталог пользователя)"
                ],
                correct: "D",
            },
            {
                name: "#2    Что такое домашний каталог пользователя?",
                answers: [
                    "Корневой каталог файловой системы",
                    "Общий каталог для всех пользователей",
                    "Каталог, предназначенный для хранения личных файлов пользователя",
                    "Временный каталог, очищаемый при каждом выходе из системы"
                ],
                correct: "C",
            },
            {
                name: "#3    Какой командой можно изменить рабочий каталог?",
                answers: [
                    "mkdir",
                    "ls",
                    "grep",
                    "cd"
                ],
                correct: "D",
            },
            {
                name: "#4    Каким будет относительный путь для файла /etc/dpkg/origins/debian, если текущий рабочий каталог /etc/dpkg?",
                answers: [
                    "./origins/debian",
                    "/etc/./origins/debian",
                    "dpkg/origins/debian",
                    "../origins/debian"
                ],
                correct: "A",
            },
            {
                name: "#5    Что означает символ тильда ~ в команде cd ~?",
                answers: [
                    "Переход в корневой каталог",
                    "Смена рабочего каталога на уровень выше",
                    "Смена рабочего каталога на домашний каталог текущего пользователя",
                    "Смена рабочего каталога на системный каталог пользователя"
                ],
                correct: "C",
            },
        ],
        conclusion: [
            {
                component: Title,
                text: 'Итого',
            },
            {
                component: Paragraph,
                text: 'В этом уроке мы узнали, как командная оболочка представляет структуру каталогов системе, а еще научились использовать абсолютные и относительные пути и познакомились с основными командами для перемещения по этой структуре.',
            },
            {
                component: Replica,
                image: cheers,
                text: 'Ты делаешь большие успехи, так держать! В следующем уроке мы используем эти знания в процессе исследования системы, чтобы стать еще сильнее!',
                isRight: false,
                align: 'flex-start',
                height: '9.375rem'
            },
        ],
    },
    {
        chapter: 'Исследование системы',
        content: [
            {
                component: Title,
                text: 'Расширенные возможности ls',
            },
            {
                component: Paragraph,
                text: 'Так же как Windows, Unix-подобная операционная система, такая как Linux, организует свои файлы в иерархическую структуру каталогов. То есть каталоги (в других системах их иногда называют папками) имеют древовидную организацию и могут содержать файлы и другие каталоги. Первый каталог в файловой системе называется корневым каталогом. Корневой каталог содержит файлы и подкаталоги, которые в свою очередь также содержат файлы и каталоги, и т. д.',
            },
            {
                component: Paragraph,
                text: 'Теперь, когда мы знаем, как перемещаться по файловой системе, совершим обзорное путешествие по системе Astra Linux. Но сначала познакомимся с еще несколькими командами, которые пригодятся нам в пути.',
            },
            {
                component: Paragraph,
                text: 'Команда <ls> является, пожалуй, одной из самых часто используемых команд, и не без весомых на то причин. С ее помощью можно увидеть, что находится в каталоге, и узнать некоторые важные атрибуты файлов и каталогов. Как мы уже видели, чтобы получить список файлов и подкаталогов в текущем рабочем каталоге, достаточно просто ввести команду <ls>.',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! ls\n<lb>Desktop</lb>   <lb>SystemWallpapers</lb>  <b>Документы</b>  <b>Изображения</b>  <b>Общедоступные</b>\n<b>Desktops</b>  <b>Видео</b>             <b>Загрузки</b>   <b>Музыка</b>       <b>Шаблоны</b>',
            },
            {
                component: Paragraph,
                text: 'Команде также можно явно указать каталог, содержимое которого требуется вывести.',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! ls /usr\n<b>bin</b>  <b>games</b>  <b>include</b>  <b>lib</b>  <b>lib32</b>  <b>lib64</b>  <b>libexec</b>  <b>local</b>  <b>sbin</b>  <b>share</b>  <b>src</b>',
            },
            {
                component: Paragraph,
                text: 'Можно также указать несколько каталогов, содержимое которых нужно вывести. Попробуем вывести содержимое каталога </usr> вновь, добавив к нему символ <~> из прошлого урока (означает домашний каталог пользователя).',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! ls ~ /usr\n/home/robocat:\n<lb>Desktop</lb>   <lb>SystemWallpapers</lb>  <b>Документы</b>  <b>Изображения</b>  <b>Общедоступные</b>\n<b>Desktops</b>  <b>Видео</b>             <b>Загрузки</b>   <b>Музыка</b>       <b>Шаблоны</b>\n/usr:\n<b>bin</b>  <b>games</b>  <b>include</b>  <b>lib</b>  <b>lib32</b>  <b>lib64</b>  <b>libexec</b>  <b>local</b>  <b>sbin</b>  <b>share</b>  <b>src</b>',
            },
            {
                component: Paragraph,
                text: 'Можно также изменить формат вывода, чтобы получить больше информации, добавив дополнительные символы.',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! ls -l /usr\nитого 104\ndrwxr-xr-x   2 root root  36864 янв 23 20:41 <b>bin</b>\ndrwxr-xr-x   2 root root   4096 янв 23 20:31 <b>games</b>\ndrwxr-xr-x  14 root root   4096 янв 23 20:36 <b>include</b>\ndrwxr-xr-x  94 root root  12288 янв 23 20:41 <b>lib</b>\ndrwxr-xr-x  29 root root   4096 янв 23 20:34 <b>lib32</b>\ndrwxr-xr-x   3 root root   4096 янв 23 20:31 <b>lib64</b>',
            },
            {
                component: Paragraph,
                text: 'Параметр <-l>, добавленный к команде, определяет формат ее вывода как «длинный» (l - long).',
            },
            {
                component: Title,
                text: 'Параметры и аргументы',
            },
            {
                component: Paragraph,
                text: 'Мы подошли к очень важному моменту, касающемуся особенностей работы большинства команд. Команды часто сопровождаются одним или несколькими параметрами, изменяющими их поведение, и дополнительными аргументами, на которые воздействует команда. Поэтому структура большинства команд выглядит примерно так:',
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: 'команда -параметры аргументы',
            },
            {
                component: Paragraph,
                text: 'Большинство команд используют параметры, состоящие из одного символа, перед которым стоит дефис, например: <-l>. Но многие команды, в том числе команды из проекта <GNU>, поддерживают параметры с длинными именами, состоящие из слова, перед которым стоит два дефиса.',
            },
            {
                component: Paragraph,
                text: 'Кроме того, многие команды позволяют объединять вместе параметры с короткими именами. В следующем примере команде <ls> передаются два параметра: параметр <l>, требующий использовать длинный (long) формат вывода, и параметр <t>, требующий сортировать результаты по времени (time) изменения:',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! ls -lt',
            },
            {
                component: Paragraph,
                text: 'Добавим теперь параметр с длинным именем <--reverse>, чтобы изменить порядок сортировки на обратный:',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! ls -lt --reverse',
            },
            {
                component: Replica,
                isRight: false,
                align: 'flex-end',
                image: think,
                text: 'Будь внимателен, когда добавляешь параметры к командам, поскольку они всегда чувствительны к регистру. Это значит, что опции -l и -L дадут совершенно разный результат!',
            },
            {
                component: Paragraph,
                text: 'Команда <ls> имеет огромное количество допустимых параметров. Наиболее популярные из них перечислены в таблице ниже.',
            },
            {
                component: CustomTable,
                data: [
                    ['Параметр', 'Длинный параметр', 'Описание'],
                    ['-a', '--all', 'Список всех (all) файлов, даже с именами, начинающимися с точки, которые обычно не выводятся (скрытых)'],
                    ['-A', '--almost-all', 'Действует подобно параметру -a, но не выводит каталоги . (текущий рабочий каталог) и .. (родительский каталог)'],
                    ['-d', '-directory', 'Обычно в присутствии этого параметра команда ls выводит информацию о самом каталоге, а не его содержимое. Используйте этот параметр в сочетании с параметром -l, чтобы получить дополнительную информацию о каталоге'],
                    ['-F', '--classify', 'Добавляет в конец каждого имени символ-индикатор (например, прямой слеш, если это имя каталога)'],
                    ['-h', '--human-readable', 'При использовании длинного формата вывода отображает размеры файлов не в байтах, а в величинах с единицами измерения'],
                    ['-l', '', 'Выводит результаты с использованием длинного формата'],
                    ['-r', '--reverse', 'Выводит результаты в обратном алфавитном порядке'],
                    ['-S', '', 'Сортировать результаты по размеру (size)'],
                    ['-t', '', 'Сортировать результаты по времени (time) последнего изменения'],
                ],
            },
            {
                component: Replica,
                isRight: false,
                align: 'flex-end',
                image: tongue,
                text: 'Но как же запомнить все эти параметры? Кажется, что для каждой команды их бесчисленное множество и все они делают совершенно разные вещи… Не переживай! В системе Astra Linux существуют несколько систем помощи, благодаря которым ты легко найдешь нужную информацию. Но об этом чуть позднее ;)',
            },
            {
                component: Title,
                text: 'Длинный формат',
            },
            {
                component: Paragraph,
                text: 'Как было показано выше, параметр <-l> заставляет команду <ls> выводить результаты с использованием длинного формата. Этот формат предусматривает вывод большого количества полезной информации. Давайте взглянем на него еще раз.',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~/Desktop$! ls -l\nитого 36\n-rw-r--r-- 1 robocat robocat 7374 янв 23 20:43 firefox.desktop\n-rw-r--r-- 1 robocat robocat  263 янв 23 20:43 fly-help.desktop\n-rw-r--r-- 1 robocat robocat  362 янв 23 21:00 fly-term.desktop\n-rw-r--r-- 1 robocat robocat  155 янв 23 20:43 mycomp.desktop\n-rw-r--r-- 1 robocat robocat  185 янв 23 20:43 mytrash.desktop',
            },
            {
                component: Paragraph,
                text: 'Рассмотрим различные поля для одного из файлов и их назначение.',
            },
            {
                component: CustomTable,
                data: [
                    ['Поле', 'Назначение'],
                    ['-rw-r-r-', 'Права доступа к файлу. Первый символ указывает тип файла.  Например, символом дефиса обозначаются обычные файлы, а символом d — каталоги. Следующие три символа сообщают о правах доступа для владельца файла, следующие три — для членов группы, которой принадлежит файл, и последние три — для всех остальных. Более полный обзор прав доступа приведем в других главах'],
                    ['1', 'Число жестких ссылок на файл. Подробнее о ссылках узнаем в главе про файловую систему Linux'],
                    ['robocat', 'Имя пользователя, владеющего файлом'],
                    ['robocat', 'Имя группы, владеющей файлом'],
                    ['263', 'Размер файла в байтах'],
                    ['янв 23 20:43', 'Дата и время последнего изменения файла'],
                    ['fly-help.desktop', 'Имя файла'],
                ],
            },
            {
                component: Title,
                text: 'Определение типов файлов',
            },
            {
                component: Paragraph,
                text: 'Занимаясь исследованием системы, полезно иметь возможность определять тип содержимого файлов. В этом нам может помочь команда <file>.',
            },
            {
                component: InfoBlock,
                text: 'Стоит отметить, что имена файлов в Linux не обязаны отражать тип содержимого файлов. Например, увидев имя файла picture.jpg, можно предположить, что он содержит изображение в формате JPEG, но в Linux такие предположения могут не оправдываться.',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~/Desktop$! file fly-help.desktop\nfly-help.desktop: UTF-8 Unicode text',
            },
            {
                component: Paragraph,
                text: 'Вывод команды показывает, что файл <fly-help.desktop> является текстовым файлом в кодировке UTF-8.',
            },
            {
                component: InfoBlock,
                text: 'Существует множество разных типов файлов. Одна из известных идей в Unix-подобных системах, таких как Linux, гласит: «Все сущее есть файл». По мере изучения системы, типы многих файлов будут вам знакомы, например файлы MP3 и JPEG, но иногда будут попадаться файлы с малоизвестными и даже странными типами.',
            },
            {
                component: Title,
                text: 'Просмотр содержимого',
            },
            {
                component: Paragraph,
                text: 'Команда <less> — это программа для просмотра текстовых файлов. В системе Astra Linux присутствует множество файлов, содержащих обычный читаемый текст, а программа <less> предоставляет удобный способ исследовать их содержимое.',
            },
            {
                component: Paragraph,
                text: 'Зачем может понадобиться исследовать текстовые файлы? Дело в том, что многие файлы с системными настройками (их называют конфигурационными файлами) хранят информацию в этом формате, что дает возможность прочитать их и вникнуть в особенности работы системы. Кроме того, в этом формате хранятся многие программы (их называют сценариями).',
            },
            {
                component: Paragraph,
                text: 'Запустим команду <less> для файла со всеми известными системе учетными записями пользователей:',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! less /etc/passwd',
            },
            {
                component: Paragraph,
                text: 'После запуска программа <less> выведет содержимое файла, которое можно прокручивать вверх и вниз с помощью мыши или соответствующих клавиш. Чтобы выйти из программы <less>, нажмите клавишу <Q>.',
            },
            {
                component: InfoBlock,
                text: 'Программа less создавалась как улучшенная замена более ранней Unix-программы с именем more. Ее имя — это игра слов «less is more» (меньше значит больше) — девиз архитекторов-модернистов и проектировщиков. less относится к категории программ постраничного просмотра текстовых документов. В отличие от программы more, которая может листать страницы только вперед, программа less способна листать текст в обоих направлениях, вперед и назад, и имеет множество других особенностей.',
            },
            {
                component: Replica,
                isRight: true,
                image: like,
                align: 'flex-start',
                text: 'Попробуй использовать команду more для файла /etc/passwd и увидишь разницу! Пролистывать содержимое с этой командой можно с помощью пробела.',
            },
            {
                component: Title,
                text: 'Обзорное путешествие',
            },
            {
                component: Paragraph,
                text: 'Файловая система в Linux имеет практически ту же компоновку, что и в других Unix-подобных системах. Фактически ее структура определяется опубликованным стандартом с названием «Linux Filesystem Hierarchy Standard».',
            },
            {
                component: Paragraph,
                text: 'Теперь, наконец, немного попутешествуем по файловой системе с помощью изученных команд и попрактикуемся в навигации. Первое, что мы обнаружим: многие интересные файлы имеют простой текстовый формат. В ходе путешествия пробуйте выполнить следующие действия:',
            },
            {
                component: List,
                list: [
                    'с помощью команды <cd> перейдите в интересующий каталог',
                    'выведите содержимое каталога командой <ls -l>',
                    'если увидите заинтересовавший вас файл, определите его тип командой <file>',
                    'если файл выглядит как текстовый, попробуйте просмотреть его командой <less>',
                ],
            },
            {
                component: Paragraph,
                text: 'Если по ошибке вы попробовали просмотреть содержимое нетекстового файла и полностью нарушили нормальную работу окна терминала, вы можете вернуть его в исходное состояние, выполнив команду <reset>.',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! reset',
            },
            {
                component: Paragraph,
                text: 'В ходе путешествия не бойтесь заглядывать внутрь системы. Обычные пользователи практически ничего не смогут испортить. Это работа системного администратора! Если команда пожалуется на что-то, просто перейдите к чему-нибудь другому. Потратьте некоторое время на знакомство с окрестностями. Это наша система, и мы вправе заниматься ее исследованием.',
            },
            {
                component: Paragraph,
                text: '', // Do not delete
            },
        ],
        tests: [
            {
                name: "#1    Чем являются -l и /usr в команде ls -l /usr?",
                answers: [
                    "-l – это путь к файлу, /usr – параметр команды ls",
                    "-l – это аргумент команды ls, /usr – параметр команды",
                    "-l – это опция команды ls, /usr – аргумент команды",
                    "-l и /usr – это аргументы команды"
                ],
                correct: "C",
            },
            {
                name: "#2    Выберите верные способы объединения нескольких параметров",
                answers: [
                    "В командной строке все параметры обязательно разделяются запятыми",
                    "Параметры можно объединять без разделителей: -abc или -a -b -c",
                    "Параметры можно объединять только при помощи скобок: (-a -b -c)",
                    "Необходимо использовать только одинарные кавычки: '-a -b -c'"
                ],
                correct: "B",
            },
            {
                name: "#3    Чем являются загадочные наборы символов -rw-r-r-?",
                answers: [
                    "Контрольной суммой файла",
                    "Уровнем доступа к файлу",
                    "Засекреченной датой последнего изменения файла",
                    "Права доступа к файлу в формате символьного представления"
                ],
                correct: "D",
            },
            {
                name: "#4    В чем отличие команд less и more?",
                answers: [
                    "Команды выполняют одну и ту же задачу одинаково",
                    "less позволяет просматривать файл в обе стороны, а more только вниз",
                    "Команды предназначены для разных типов файлов",
                    "more умеет искать по содержимому файла, в отличие от less"
                ],
                correct: "B",
            },
            {
                name: "#5    Определите тип файла /etc/dpkg/origins/debian",
                answers: [
                    "Zip-архив",
                    "Текстовый файл",
                    "Исполняемый файл",
                    "Конфигурационный файл"
                ],
                correct: "B",
            },
        ],
        conclusion: [
            {
                component: Title,
                text: 'Итого',
            },
            {
                component: Paragraph,
                text: 'Совершив первое обзорное путешествие, мы узнали много нового о нашей системе. Мы увидели разные файлы, каталоги и их содержимое. В ходе урока мы познакомились с одними из самых полезных команд и их параметрами, а также научились узнавать тип файла и просматривать его содержимое в удобном формате.',
            },
            {
                component: Replica,
                image: smile,
                text: 'Молодец! Я чувствую, что становлюсь все сильнее, прокачивая свои навыки вместе с тобой.',
                isRight: false,
                align: 'flex-start',
            },
        ],
    },
    {
        chapter: 'Работа с командами',
        content: [
            {
                component: Title,
                text: 'Что такое команды?',
            },
            {
                component: Paragraph,
                text: 'До настоящего момента мы видели группы мистических команд, каждая из которых имеет свои таинственные параметры и аргументы. Теперь мы удалим часть этой таинственности и даже создадим несколько собственных команд.',
            },
            {
                component: Replica,
                image: think,
                isRight: false,
                align: 'flex-end',
                text: 'Используя команды из предыдущих уроков, задумывался ли ты над тем, что это такое? Чем является команда на самом деле? Эти вопросы кажутся очень сложными, поэтому давай скорее разбираться!',
            },
            {
                component: Paragraph,
                text: 'Команда может быть:',
            },
            {
                component: List,
                list: [
                    'Выполняемой программой, как те файлы, что мы видели в каталоге </usr/bin>. К этой категории относятся: скомпилированные двоичные программы (например, написанные на <C> и <C++>); программы, написанные на языках сценариев (<shell>, <Perl>, <Python>, <Ruby> и др.)',
                    'Встроенной командой, реализованной внутри самой командной оболочки. Командная оболочка <bash> поддерживает множество внутренних команд, которые так и называют — встроенными (<shell builtins>). Команда <cd>, например, — это встроенная команда',
                    'Функцией командной оболочки. Функции командной оболочки (<shell functions>) — это миниатюрные сценарии на языке командной оболочки, встроенные в окружение',
                    'Псевдонимом. Псевдоним (<alias>) — это команда, которую мы можем определить сами, сконструировав из других команд'
                ],
            },
            {
                component: Title,
                text: 'Идентификация команд',
            },
            {
                component: Paragraph,
                text: 'Часто бывает полезно точно знать, какому из четырех типов принадлежит команда, и Linux предлагает пару способов узнать это.',
            },
            {
                component: Subtitle,
                text: 'type — получение типа команды',
            },
            {
                component: Paragraph,
                text: 'Команда <type> — это встроенная команда, которая сообщает тип указанной ей команды. Вызывается она следующим образом:',
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: '!robocat@astra:~$! type type\ntype — это встроенная команда bash\n!robocat@astra:~$! type ls\nls — это псевдоним для «ls --color=auto»',
            },
            {
                component: Paragraph,
                text: 'Здесь мы видим результаты определения типов трех разных команд. Обратите внимание, что команда <ls> фактически является псевдонимом (<alias>) команды <ls> с параметром <--color=tty>. Теперь мы знаем, почему результаты команды <ls> отображаются в цвете!',
            },
            {
                component: Subtitle,
                text: 'which — определение местоположения выполняемого файла',
            },
            {
                component: Paragraph,
                text: 'Иногда в системе имеется более одной версии исполняемой программы. Это довольно редкое явление для настольных систем, но вполне обычное для больших серверов. Точно определить местоположение данного исполняемого файла позволяет команда <which>:',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! which ls\n/bin/ls',
            },
            {
                component: Paragraph,
                text: 'Команда <which> ищет только исполняемые программы, она не способна выявлять встроенные команды или псевдонимы, замещающие фактические исполняемые программы. Если попытаться с помощью <which> определить местоположение встроенной команды (например, <cd>), мы либо ничего не получим, либо получим сообщение об ошибке.',
            },
            {
                component: Title,
                text: 'Получение описания команд',
            },
            {
                component: Paragraph,
                text: 'Теперь, зная тип команды, можно поискать документацию с описанием, доступную для каждого вида команд.',
            },
            {
                component: Subtitle,
                text: 'help — получение справки для встроенных команд',
            },
            {
                component: Paragraph,
                text: '<bash> имеет встроенную справку для каждой встроенной команды. Чтобы получить ее, введите <help> с именем встроенной команды. Например:',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! help cd\ncd: cd [-L|[-P [-e]] [-@]] [каталог]\n    Change the shell working directory.\n     \n    Change the current directory to DIR.  The default DIR is the value of the\n    HOME shell variable.\n         The variable CDPATH defines the search path for the directory containing\n    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n    A null directory name is the same as the current directory.  If DIR begins\n    with a slash (/), then CDPATH is not used.',
            },
            {
                component: Paragraph,
                text: 'Квадратные скобки в описании синтаксиса команды указывают на необязательность элемента. Вертикальная черта используется для перечисления взаимоисключающих вариантов. В примере с описанием команды <cd>, приведенном выше, ее синтаксис описывается как:',
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: 'cd [-L|[-P[-e]]] [dir]',
            },
            {
                component: Paragraph,
                text: 'Эта форма записи говорит, что команда <cd> может принимать необязательный параметр <-L> или <-P> и необязательный аргумент <dir>. Если указан параметр <-P>, вместе с ним можно также передать параметр <-e>.',
            },
            {
                component: Paragraph,
                text: 'Несмотря на то, что <help> дает краткое и точное описание команды <cd>, это описание не может служить инструкцией по использованию, и, как вы можете видеть, в нем упоминается многое из того, чего мы еще не знаем! Но не волнуйтесь, со всем этим мы познакомимся в свое время.',
            },
            {
                component: Subtitle,
                text: '--help — вывод инструкции по использованию',
            },
            {
                component: Paragraph,
                text: 'Многие выполняемые программы поддерживают параметр <--help> для вывода описания синтаксиса и параметров, поддерживаемых командой. Например:',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! arch --help\nИспользование: arch [КЛЮЧ]…\nПечатает машинную архитектуру.\n\n\n      --help     показать эту справку и выйти\n      --version  показать информацию о версии и выйти',
            },
            {
                component: Paragraph,
                text: 'Некоторые программы не поддерживают параметр <--help>, но вы все равно пробуйте передать его. Часто в результате выводится сообщение об ошибке, содержащее ту же информацию о порядке использования.',
            },
            {
                component: Subtitle,
                text: 'man — вывод страниц справочного руководства',
            },
            {
                component: Paragraph,
                text: 'Большинство программ, предназначенных для использования в командной строке, предоставляют официальную документацию, которую называют страницей справочного руководства (man-страницу). Для просмотра этих страниц используется специальная программа постраничного просмотра <man> (manual).',
            },
            {
                component: Paragraph,
                text: 'Страницы справочного руководства могут несколько отличаться друг от друга оформлением, но в общем случае содержат:',
            },
            {
                component: List,
                list: [
                    'заголовок (название страницы)',
                    'краткий обзор синтаксиса команды',
                    'описание назначения команды',
                    'список всех параметров с их описанием',
                ],
            },
            {
                component: Paragraph,
                text: 'Однако страницы справочного руководства обычно не включают примеры использования, и их главная цель — служить справочником, а не инструкцией по использованию. Для примера попробуйте вывести страницу справочного руководства для команды <uname>:',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! man uname',
            },
            {
                component: Paragraph,
                text: 'В большинстве систем Linux man использует <less> для вывода страницы, поэтому при просмотре страницы можно использовать все известные команды <less>.',
            },
            {
                component: Subtitle,
                text: 'whatis — вывод очень краткого описания команды',
            },
            {
                component: Paragraph,
                text: 'Программа <whatis> выводит имя и однострочное описание из страницы справочного руководства, соответствующей искомому слову:',
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: '!robocat@astra:~$! whatis df\ndf (1)              - отчёт об использовании дискового пространства\n!robocat@astra:~$! whatis tty\ntty (1) - выводит имя терминала соединённого со стандартным вводом',
            },
            {
                component: Paragraph,
                text: 'Программа <whatis> является самым быстрым способом узнать краткую информацию об интересующей команде.',
            },
            {
                component: Replica,
                image: like,
                isRight: false,
                align: 'flex-end',
                text: 'Изучая системы помощи, мы познакомились с еще несколькими полезными командами. Прочитай их описания с помощью изученных команд и попробуй ввести в командную строку!',
            },
            {
                component: Title,
                text: 'Создание собственных команд',
            },
            {
                component: Paragraph,
                text: 'А теперь проведем первый опыт по программированию! У нас есть возможность создавать собственные команды с помощью команды <alias>. Но прежде чем начать, познакомимся с одной маленькой хитростью командной строки. Она позволяет уместить в одной строке несколько команд, отделяя их друг от друга точкой с запятой:',
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: 'команда1; команда2; команда3...',
            },
            {
                component: Paragraph,
                text: 'Следующий пример демонстрирует этот прием:',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! cd ..; echo "Запрыгнули наверх! Текущая директория:"; pwd\nЗапрыгнули наверх! Текущая директория:\n/home\n',
            },
            {
                component: Paragraph,
                text: 'Первая команда меняет рабочий каталог на родительский (тем самым совершается прыжок наверх), вторая команда выводит на экран уведомление о прыжке, а с помощью третьей мы узнаем в каком каталоге оказались.',
            },
            {
                component: Paragraph,
                text: 'Давайте теперь с помощью <alias> превратим эту последовательность в новую команду. Первое, что мы должны сделать, — придумать имя для новой команды. Пусть это будет <jump>. Но прежде чем продолжить, хорошо бы проверить, не занято ли уже имя <test>. Для этого воспользуемся командой <type>:',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:/home$! type jump\nbash: type: jump: не найден',
            },
            {
                component: Paragraph,
                text: 'Отлично! Имя <jump> свободно. Теперь создадим наш псевдоним, используя команду <alias> по следующей структуре:',
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: "alias имя='строка с командами'",
            },
            {
                component: Paragraph,
                text: 'За командой <alias> следует имя, за которым без пробелов следует знак «равно» и строка в кавычках, описывающая действие, присваиваемое имени. После определения псевдонима его можно использовать везде, где ожидается команда. Давайте попробуем:',
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: `!robocat@astra:~$! alias jump='cd ..; echo "Запрыгнули наверх! Текущая директория:"; pwd'\n!robocat@astra:~$! jump\nЗапрыгнули наверх! Текущая директория:\n/home\n!robocat@astra:/home$!`,
            },
            {
                component: Paragraph,
                text: 'Отлично! Теперь у нас есть собственная команда. Давайте определим ее тип с помощью команды <type>:',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: `!robocat@astra:~$! type jump\njump — это псевдоним для «cd ..; echo "Запрыгнули наверх! Текущая директория:"; pwd»`,
            },
            {
                component: Paragraph,
                text: 'Все верно! Если вы вдруг передумали или хотите изменить функционал команды, можно удалить существующий псевдоним с помощью <unalias>:',
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: '!robocat@astra:~$! unalias jump\n!robocat@astra:~$! type jump    \nbash: type: jump: не найден',
            },
            {
                component: InfoBlock,
                text: 'Существует одна проблема, связанная с определением псевдонимов в командной строке. Они исчезают по завершении сеанса работы с командной оболочкой. В следующих уроках будет показано, как добавить определения псевдонимов в файлы, чтобы они восстанавливались при каждом запуске командной оболочки.',
            },
            {
                component: Paragraph,
                text: 'Теперь, когда мы узнали, как найти документацию с описанием команд, поупражняйтесь самостоятельно и найдите описание всех команд, встретившихся вам в этом уроке. Познакомьтесь с их дополнительными параметрами и опробуйте их в действии!',
            },
            {
                component: Paragraph,
                text: '', // Do not remove
            },
            {
                component: Paragraph,
                text: '', // Do not remove
            },
        ],
        tests: [
            {
                name: "#1    Что такое алиас?",
                answers: [
                    "Псевдоним для пользовательского набора команд",
                    "Программа для создания архивов",
                    "Системное ядро операционной системы",
                    "Пользователь UNIX"
                ],
                correct: "A",
            },
            {
                name: "#2    С помощью чего можно определить тип команды?",
                answers: [
                    "Во время проведения индексирования файловой системы",
                    "С помощью команды whatis",
                    "Используя утилиту для подсчета количества файлов",
                    "С помощью команды type"
                ],
                correct: "D",
            },
            {
                name: "#3    Какая утилита позволит получить справку для встроенных команд?",
                answers: [
                    "Поисковая система Google",
                    "Программа для поиска файлов по различным критериям",
                    "Команда help",
                    "Опция --help"
                ],
                correct: "C",
            },
            {
                name: "#4    С помощью какого параметра можно получить вывод инструкции по использованию?",
                answers: [
                    "--help",
                    "--info",
                    "--man",
                    "--u"
                ],
                correct: "A",
            },
            {
                name: "#5    Какая программа является самым быстрым способом получить информацию об объекте?",
                answers: [
                    "whois",
                    "which",
                    "man",
                    "whatis"
                ],
                correct: "D",
            },
        ],
        conclusion: [
            {
                component: Title,
                text: 'Итого',
            },
            {
                component: Replica,
                image: cheers,
                text: 'Так держать! Ты отлично справился с последним разделом в этом модуле и теперь знаешь множество возможностей командной строки Linux. На самом деле, это лишь малая часть того, на что способна система. Не останавливайся на достигнутом и продолжай учиться! В следующем модуле мы подробно рассмотрим более продвинутые темы, так что будь готов к новым вызовам. Я уверен, что ты справишься с ними на отлично!',
                isRight: false,
                align: 'flex-end',
                height: '9.375rem'
            },
            {
                component: Paragraph,
                text: 'Чтобы я смог и дальше развивать свои навыки и делать обучение более интересным и увлекательным, пожалуйста, расскажи о том, с какими трудностями ты столкнулся, изучая основы командной строки в этом модуле. Ты также можешь поделиться своими идеями о том, как я могу стать лучше.',
            },
            {
                component: ReviewBlock,
            }
        ],
    },
    {
        chapter: 'Текстовый редактор vim',
        content: [
            {
                component: Title,
                text: 'Зачем осваивать vim',
            },
            {
                component: Paragraph,
                text: 'Основным текстовым редактором командного режима операционных систем семейства UNIX является <vi>. Он был разработан одним из авторов UNIX BSD и создателем фирмы Sun Microsystems Билли Джоем. В современных Linux используется современная версия, называемая <vim>.',
            },
            {
                component: Replica,
                isRight: false,
                image: think,
                align: 'flex-start',
                text: 'Зачем в современном мире простых редакторов с графическим интерфейсом осваивать vim?',
            },
            {
                component: Paragraph,
                text: 'Знание правил использования программы <vim> поможет в ситуации, когда необходимо редактировать текстовые файлы, а других программ, выполняющих такую функцию, нет. Эта ситуация может возникнуть при минимальной конфигурации операционной системы Linux, например, при восстановлении системы после сбоя.',
            },
            {
                component: Paragraph,
                text: 'Редактор <vim> также быстрый и легковесный. Для многих задач гораздо проще запустить <vim>, чем найти в меню редактор с графическим интерфейсом и ждать, пока несколько мегабайтов загрузится в память. Кроме того, <vim> специально проектировался для скоростного ввода с клавиатуры.',
            },
            {
                component: Title,
                text: 'Запуск и завершение vim',
            },
            {
                component: Paragraph,
                text: 'Теперь приступим к практике. Чтобы запустить <vim>, введите следующую команду:',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! vim',
            },
            {
                component: Paragraph,
                text: 'Появившиеся на экране надписи сообщают нам о версии запущенного <vim>, его авторах и нескольких удобных комбинациях клавиш. Поскольку <vim> все же обладает не самым лучшим пользовательским интерфейсом, чтобы не запутаться, сразу же научимся выходить из него. Для этого введите:',
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: ':q',
            },
            {
                component: Paragraph,
                text: 'В окне терминала должно появиться приглашение к вводу командной оболочки. Если по какой-то причине выход из <vim> не получился (скорее всего, потому что вы внесли какие-то изменения и еще не сохранили их), сообщите <vim>, что вы действительно хотите выйти, добавив в команду восклицательный знак:',
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: ':q!',
            },
            {
                component: InfoBlock,
                text: 'Если вы «заблудились» в vim, попробуйте дважды нажать ESC, чтобы вернуться на верный путь.',
            },
            {
                component: Title,
                text: 'Режимы редактирования',
            },
            {
                component: Paragraph,
                text: 'Давайте снова запустим <vim>, но на этот раз укажем имя текстового файла, который хотим создать:',
            },
            {
                component: CodeBlock,
                canCopy: true,
                text: '!robocat@astra:~$! vim hi.txt',
            },
            {
                component: Paragraph,
                text: 'В случае успеха на последней строке интерфейса должна появиться надпись:',
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: '“hi.txt” [Новый]',
            },
            {
                component: Paragraph,
                text: 'Начальные символы тильды <~> сообщают об отсутствии текста в соответствующих строках. Таким способом <vim> сообщает нам, что файл пуст.',
            },
            {
                component: Paragraph,
                text: 'Не вводите пока ничего! Вторая важная вещь, которую нужно усвоить (после того, как вы научились выходить), — <vim> является режимным редактором. Сразу после запуска <vim> оказывается в командном режиме. В этом режиме практически каждая клавиша является командой, поэтому если вы начнете ввод, <vim> может запутаться сам и запутать вас.',
            },
            {
                component: Title,
                text: 'Переход в режим вставки',
            },
            {
                component: Paragraph,
                text: 'Чтобы добавить какой-то текст в файл, необходимо сначала перейти в режим вставки. Для этого нажмите клавишу <i>. Вслед за этим в нижней части экрана появится надпись:',
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: '-- ВСТАВКА --',
            },
            {
                component: Paragraph,
                text: 'Теперь можно ввести какой-нибудь текст. Попробуйте, например, записать сегодняшнюю дату и оставить пометку о первом использовании <vim>.',
            },
            {
                component: Title,
                text: 'Сохранение изменений',
            },
            {
                component: Paragraph,
                text: 'Чтобы выйти из режима вставки и вернуться в командный режим, нажмите <ESC>. Чтобы выполнить запись изменений в файл, введите <:w> и нажмите <ENTER>. Файл будет записан на жесткий диск, и в нижней части появится подтверждение:',
            },
            {
                component: CodeBlock,
                canCopy: false,
                text: '“hi.txt” [Новый] 1L, 61B записано',
            },
            {
                component: Paragraph,
                text: 'Аналогично снова введем <:q> для выхода из программы.',
            },
            {
                component: Paragraph,
                text: '',
            },
            {
                component: Paragraph,
                text: '',
            },
        ],
    },
];

export const filesystemData = [
    {
        chapter: 'Основы файловой системы',
        content: [
            {
                component: Title,
                text: 'Определение',
            },
            {
                component: Paragraph,
                text: 'Представь себе библиотеку, в которой книги хаотично разбросаны по полкам, а поиск нужной информации превращается в настоящую головоломку. Примерно так выглядел бы компьютер без хорошо организованной структуры хранения данных. Именно здесь на помощь приходит файловая система!',
            },
            {
                component: Paragraph,
                text: 'Файловая система – это набор правил и методов, который определяет, каким образом данные хранятся на устройстве, будь то жесткий диск или флеш-накопитель. Она управляет процессом записи новых данных, их изменения и удаления. Это своего рода "библиотекарь" нашего компьютера, который следит за порядком среди миллионов единиц информации.',
            },
            {
                component: Title,
                text: 'Основные элементы',
            },
            {
                component: Paragraph,
                text: 'Давай подробнее разберемся с основными элементами файловой системы, такими как файлы, папки (или каталоги) и пути. Эти компоненты образуют основу любой файловой системы, включая ту, что используется в Astra Linux.',
            },
            {
                component: Paragraph,
                text: 'Файл – это основной элемент хранения данных. Он представляет собой логически обособленный объект, содержащий информацию любого типа: от документов до программных кодов. Каждый файл обладает рядом характеристик:',
            },
            {
                component: List,
                list: ['Имя: уникальное название файла внутри каталога', 'Тип: определяется расширением имени файла (*.txt, *.jpg, *.exe и другие). Расширения помогают пользователям и программам понять тип содержимого.', 'Размер: объем занимаемой памяти на диске', 'Дата создания/изменения: важные метаданные о времени последних операций над файлом']
            },
            {
                component: Paragraph,
                text: 'Папка служит контейнером для организации файлов и других папок. Ее основная задача – группировка связанных объектов. Иерархия папок формирует древовидную структуру файловой системы, начиная с корня </> и продолжаясь вниз через вложенные директории',
            },
            {
                component: Replica,
                image: smile,
                text: 'Когда ты открываешь новую папку, ты как будто заходишь в новый зал библиотеки. Все книги там тоже имеют свои полки и номера страниц!',
                isRight: false,
                align: 'flex-start',
            },
            {
                component: Paragraph,
                text: 'Пути описывают местоположение объекта (файла или папки) в структуре файловой системы. Ранее мы упоминали два вида путей: абсолютные, начинающиеся с корня файловой системы, и относительные, зависящие от текущего рабочего каталога.',
            },
            {
                component: Paragraph,
                text: 'Эти три элемента – файлы, папки и пути – являются фундаментальными строительными блоками любой файловой системы. Они позволяют эффективно управлять данными и быстро находить нужные объекты в сложной иерархии каталогов.',
            },
            {
                component: Title,
                text: 'Навигация'
            },
            {
                component: Paragraph,
                text: 'Ранее мы уже познакомились с тремя важными командами: <ls>, <cd> и <pwd>. Однако есть ещё несколько полезных инструментов, которые значительно облегчат наше путешествие по системе.',
            },
            {
                component: Paragraph,
                text: 'Команда <tree> выводит графическое представление всех файлов и папок, находящихся в текущем каталоге, вплоть до указанной глубины. Чтобы увидеть дерево папок в домашнем каталоге, можно использовать команду:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! tree ~/',
            },
            {
                component: Paragraph,
                text: 'Для того, чтобы ограничить глубину вывода, например, до двух уровней, используем параметр <-L>:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! tree -L 2 ~/',
            },
            {
                component: Paragraph,
                text: 'Команда <find> ищет файлы и папки по заданному критерию. Если ты забыл точное расположение какого-то файла, но помнишь часть его названия, эта команда станет настоящим спасательным кругом. Пример поиска всех файлов с именем "config" во всей файловой системе:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find / -name config',
            },
            {
                component: Replica,
                image: like,
                text: 'Команда find — это ваш лучший помощник в поиске пропавших файлов. Она всегда знает, где они прячутся!',
                isRight: false,
                align: 'flex-start',
            },
            {
                component: InfoBlock,
                text: 'Обрати внимание, что поиск начнется с корня файловой системы и может занять некоторое время.',
            },
            {
                component: Paragraph,
                text: 'Для более быстрого поиска существует команда <locate>, которая использует предварительно созданную базу данных файлов. Этот метод особенно полезен, если нужно выполнять поиск часто. Обновить индекс базы данных можно командой:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! sudo updatedb',
            },
            {
                component: Paragraph,
                text: 'После обновления база данных готова к поиску. Теперь можно выполнить быстрый поиск файла, например:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! locate config',
            },
            {
                component: Paragraph,
                text: 'Этот способ быстрее, чем использование <find>, поскольку не требует полного сканирования файловой системы.',
            },
            {
                component: Title,
                text: 'Действия с файлами',
            },
            {
                component: Paragraph,
                text: 'Теперь, когда мы умеем перемещаться по файловой системе и ориентироваться в её структурах, пришло время научиться выполнять основные операции с файлами. Мы рассмотрим такие действия, как создание, копирование, перемещение и удаление файлов, используя стандартные инструменты командной строки Linux.',
            },
            {
                component: Paragraph,
                text: 'Самый простой способ создать новый пустой файл — воспользоваться командой <touch>. Например, чтобы создать файл с названием "notes.txt", выполни следующую команду:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! touch notes.txt',
            },
            {
                component: Paragraph,
                text: 'Копирование файлов осуществляется с помощью команды <cp>. Необходимо  указать исходный файл и место назначения нового файла. Например, чтобы скопировать файл "original.txt" в директорию /home/user/copies с новым именем "copy.txt", введи следующее:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! cp original.txt /home/user/copies/copy.txt',
            },
            {
                component: Paragraph,
                text: 'Перемещать файлы помогает команда <mv>. Эта команда выполняет две функции: переименование и перемещение. Если хочешь переместить файл "old_name.txt" в другой каталог, укажи полный путь к новому месту расположения:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! mv old_name.txt /new/path/new_name.txt',
            },
            {
                component: Paragraph,
                text: 'Удалять ненужные файлы можно с помощью команды <rm>. Будь осторожен! После выполнения этой команды восстановить удалённый файл может стать невозможным. Попробуем удалить совсем не нужный файл "unwanted.txt":',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! rm unwanted.txt',
            },
            {
                component: Paragraph,
                text: 'А чтобы удалить целую папку со всем её содержимым, добавим флаг <-r> (обозначает рекурсивную операцию):',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! rm -r directory_to_delete',
            },
        ],
        tests: [
            {
                name: "#1    Что такое файловая система?",
                answers: [
                    "Набор правил и методов, определяющих порядок хранения данных на устройстве",
                    "Программа для управления файлами",
                    "Физическая структура жесткого диска",
                    "Операционная система для работы с файлами"
                ],
                correct: "A",
            },
            {
                name: "#2    Какой командой можно вывести графическое представление всех файлов и папок в текущем каталоге?",
                answers: [
                    "find",
                    "tree",
                    "ls",
                    "mkdir"
                ],
                correct: "B",
            },
            {
                name: "#3    Как называется команда для поиска файлов в файловой системе?",
                answers: [
                    "grep",
                    "find",
                    "locate",
                    "pwd"
                ],
                correct: "B",
            },
            {
                name: "#4    Какую функцию выполняет команда mv при перемещении файлов?",
                answers: [
                    "Только переименовывает файлы",
                    "Только перемещает файлы",
                    "Выполняет обе функции: переименование и перемещение",
                    "Создает резервные копии файлов"
                ],
                correct: "C",
            },
            {
                name: "#5    Какая команда позволяет удалить все содержимое папки вместе с самой папкой?",
                answers: [
                    "rmdir",
                    "rm -r",
                    "del",
                    "rm"
                ],
                correct: "B",
            },
        ],
        conclusion: [
            {
                component: Title,
                text: 'Итого',
            },
            {
                component: Paragraph,
                text: 'В этом уроке мы познакомились с основами файловой системы, узнали, как ориентироваться в ней с помощью командной строки и выполнять базовые операции с файлами. Не останавливайся на достигнутом — впереди ещё много интересного. Практикуйся, развивайся и покоряй новые вершины!',
            },
            {
                component: Paragraph,
                text: '',
            },
        ],
    },
    {
        chapter: 'Базовая структура каталогов',
        content: [
            {
                component: Title,
                text: 'Стандарты системы',
            },
            {
                component: Paragraph,
                text: 'Теперь давай разберемся, что такое стандарт файловой иерархии (FHS — Filesystem Hierarhy Standard), и почему он так важен при работе с операционной системой Astra Linux.',
            },
            {
                component: Paragraph,
                text: 'Представь себе ситуацию: ты работаешь над проектом, а потом тебе нужно передать результаты работы другому человеку. Если у вас нет единого соглашения о том, куда класть те или иные данные, то возникает путаница. Так вот, FHS — это своего рода соглашение между разработчиками операционных систем и программных продуктов о том, какие папки должны быть использованы для хранения определённых типов файлов. Это делает систему более предсказуемой и понятной всем пользователям.',
            },
            {
                component: InfoBlock,
                text: 'Этот стандарт был разработан сообществом Linux Foundation ещё в начале девяностых годов прошлого века. Он помогает упорядочить структуру файловой системы, чтобы каждый элемент находился там, где от него ожидают разработчики и пользователи.',
            },
            {
                component: Paragraph,
                text: 'Когда ты знаешь, что за каждым типом файла закреплена своя "домашняя" папка, это упрощает поиск нужных данных. Например, если ты ищешь конфигурационные файлы программы, то можно сразу заглянуть в </etc>, а не искать во всей системе. Следование стандартам позволяет снизить вероятность ошибок при установке новых приложений и обновлении существующих. Большинство дистрибутивов Linux, включая Astra Linux, придерживаются этого стандарта.',
            },
            {
                component: Replica,
                image: think,
                text: 'А что, если бы в реальной жизни тоже были стандарты для хранения вещей? Например, все носки лежали бы в одном месте, а не разбросаны по всему дому!',
                isRight: false,
                align: 'flex-start',
            },
            {
                component: Paragraph,
                text: 'Для понимания структуры выполним команду <ls /> – она покажет содержимое корня файловой системы. Вот пример вывода:',
            },
            {
                component: CodeBlock,
                text: 'bin   dev    home   lib64     media  opt   root  sbin   sys  usr\nboot  etc    lib    lost+found mnt    proc  run   srv    tmp  var',
            },
            {
                component: Title,
                text: 'Основные директории',
            },
            {
                component: Paragraph,
                text: 'Итак, пришло время познакомиться поближе с основными директориями нашей файловой системы. Давай посмотрим, что именно представляет собой каждая из ключевых директорий.',
            },
            {
                component: Paragraph,
                text: '\n',
            },
            {
                component: Paragraph,
                text: '</root>',
            },
            {
                component: Paragraph,
                text: 'Это домашний каталог суперпользователя (администратора). Здесь хранятся персональные файлы администратора, например, документы, настройки окружения и скрипты. Для обычного пользователя эта директория недоступна. Однако стоит помнить, что директорию </root> не стоит путать с корнем файловой системы (</>), хотя название может ввести в заблуждение.',
            },
            {
                component: Paragraph,
                text: 'Команда для просмотра содержимого этой директории:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! sudo ls /root',
            },
            {
                component: Paragraph,
                text: 'Чтобы увидеть результат выполнения команды, необходимо обладать правами суперпользователя.',
            },
            {
                component: Paragraph,
                text: '\n',
            },
            {
                component: Paragraph,
                text: '</home>',
            },
            {
                component: Paragraph,
                text: 'Здесь расположены домашние каталоги обычных пользователей системы. Каждый пользователь получает собственную папку внутри </home>. Внутри домашней директории хранится вся личная информация пользователя: документы, музыка, изображения и другие файлы. Также здесь располагаются настройки большинства приложений, используемых пользователем.',
            },
            {
                component: Paragraph,
                text: '\n',
            },
            {
                component: Paragraph,
                text: '</usr>',
            },
            {
                component: Paragraph,
                text: 'Эта директория предназначена для хранения программного обеспечения, которое установлено пользователем. Обычно сюда попадают все приложения, библиотеки и документация. Внутри </usr> есть несколько важных подпапок:',
            },
            {
                component: List,
                list: ['</usr/bin>: бинарные исполняемые файлы для запуска программ', '</usr/lib>: библиотеки, необходимые программам для корректного функционирования', '</usr/share>: общие ресурсы, такие как иконки, темы оформления и другая мультимедийная информация']
            },
            {
                component: Paragraph,
                text: '\n',
            },
            {
                component: Paragraph,
                text: '</var>',
            },
            {
                component: Paragraph,
                text: 'Название происходит от слова variable (переменный). Эта директория хранит переменные данные, изменяемые в процессе работы системы. Сюда относятся журналы активности системы, очереди печати, базы данных, кэшированные страницы веб-сайтов и многое другое. Примеры полезных подпапок:',
            },
            {
                component: List,
                list: ['</var/log>: файлы журналов системы, позволяющие отслеживать события и ошибки', '</var/cache>: кэши различных программ, например, пакетов apt', '</var/spool>: спул-директория для почтовых сообщений и заданий печати']
            },
            {
                component: Paragraph,
                text: '\n',
            },
            {
                component: Paragraph,
                text: '</etc>',
            },
            {
                component: Paragraph,
                text: 'Дирижёрская палочка конфигурации системы! Именно здесь содержатся практически все важные конфигурационные файлы, определяющие поведение самой системы и установленных программ. Среди самых известных примеров — файл </etc/fstab>, отвечающий за монтирование дисков, и </etc/passwd>, содержащий информацию обо всех зарегистрированных пользователях.',
            },
            {
                component: Replica,
                image: tongue,
                text: 'Интересно, а что было бы, если бы у нас была только одна большая папка для всего? Наверное, пришлось бы потратить полдня, чтобы найти нужную программу!',
                isRight: true,
                align: 'flex-start',
            },
            {
                component: Title,
                text: 'Домашние каталоги',
            },
            {
                component: Paragraph,
                text: 'Каждый пользователь имеет своё собственное пространство для хранения личных файлов, настроек и документов. Это место называется домашним каталогом, и оно является важной частью организации информации в системе.',
            },
            {
                component: Paragraph,
                text: 'Домашний каталог каждого пользователя обычно располагается внутри директории </home>. Внутри этой папки создаётся отдельная подпапка для каждого зарегистрированного пользователя. Имя этой подпапки совпадает с именем пользователя. Например, если твоё имя пользователя "ivan", твой домашний каталог будет находиться здесь </home/ivan/>.',
            },
            {
                component: Paragraph,
                text: 'Чтобы перейти в свой домашний каталог, достаточно просто набрать команду:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! cd ~',
            },
            {
                component: InfoBlock,
                text: 'Символ ~ в команде cd означает "перейти в мой домашний каталог". Этот ярлык очень удобен и используется повсеместно при работе в терминале.',
            },
            {
                component: Paragraph,
                text: 'Домашний каталог состоит из нескольких стандартных поддиректорий, каждая из которых выполняет определённую функцию:',
            },
            {
                component: List,
                list: ['Документы:'],
            },
            {
                component: Paragraph,
                text: 'Обычно в домашнем каталоге создаются отдельные папки для разных типов файлов, таких как документы, изображения, музыка и видео. Эти папки служат для удобства сортировки и поиска данных.',
            },
            {
                component: List,
                list: ['Настройки:'],
            },
            {
                component: Paragraph,
                text: 'Помимо обычных файлов, в домашнем каталоге часто содержатся скрытые файлы и папки, начинающиеся с точки <.>, которые хранят различные конфигурации программ. Например, браузер Firefox может хранить свои настройки в файлах вроде <.mozilla> или <.firefox>.',
            },
            {
                component: List,
                list: ['Рабочий стол:'],
            },
            {
                component: Paragraph,
                text: 'Ещё одна важная часть домашнего каталога — это рабочий стол. Все файлы и иконки, которые ты видишь на рабочем столе, физически располагаются в этом каталоге.',
            },
            {
                component: Paragraph,
                text: 'Хорошо организованный домашний каталог позволяет быстро находить нужные файлы и эффективно управлять своими данными. Благодаря стандартизации расположения файлов и настроек, пользователи могут настраивать программы и сохранять информацию таким образом, чтобы её было удобно использовать снова и снова.',
            },
            {
                component: Paragraph,
                text: '',
            },
        ],
        tests: [
            {
                name: "#1    Где находится домашний каталог суперпользователя?",
                answers: [
                    "/home/root",
                    "/root",
                    "/usr/local/home",
                    "/var/root"
                ],
                correct: "B",
            },
            {
                name: "#2    Какая директория используется для хранения переменных данных системы?",
                answers: [
                    "/var",
                    "/tmp",
                    "/opt",
                    "/srv"
                ],
                correct: "A",
            },
            {
                name: "#3    Что содержится в директории /usr/share?",
                answers: [
                    "Бинарные исполняемые файлы",
                    "Общие ресурсы, такие как иконки и темы оформления",
                    "Конфигурационные файлы",
                    "Документация"
                ],
                correct: "B",
            },
            {
                name: "#4    Какой командой можно просмотреть содержимое домашнего каталога суперпользователя?",
                answers: [
                    "ls /root",
                    "cat /root",
                    "pwd /root",
                    "find /root"
                ],
                correct: "A",
            },
            {
                name: "#5    Какие типы файлов обычно хранятся в домашних каталогах пользователей?",
                answers: [
                    "Только рабочие документы",
                    "Личные файлы, настройки приложений и рабочий стол",
                    "Только музыка и изображения",
                    "Файлы проектов и настройки среды разработки"
                ],
                correct: "B",
            },
        ],
        conclusion: [
            {
                component: Title,
                text: 'Итого',
            },
            {
                component: Paragraph,
                text: 'Итак, мы рассмотрели базовую структуру каталогов в операционной системе Astra Linux, следуя стандарту FHS. Понимание этой структуры поможет вам эффективнее работать с файлами и приложениями, а также упростит процесс взаимодействия с системой. Знание того, где находятся ключевые элементы системы, такие как конфигурационные файлы, библиотеки и пользовательские данные, позволит быстрее решать задачи и избегать возможной путаницы.',
            },
            {
                component: Paragraph,
                text: '',
            },
        ],
    },
    {
        chapter: 'Права доступа к файлам и папкам',
        content: [
            {
                component: Title,
                text: 'Основы прав доступа',
            },
            {
                component: Paragraph,
                text: 'Что же такое права доступа и зачем они нужны? Как ты уже знаешь, каждый файл или папка в Linux имеют свои настройки безопасности — это и есть права доступа. Они определяют, какие действия могут быть выполнены над ними различными пользователями системы.',
            },
            {
                component: Replica,
                image: smile,
                text: 'Права доступа напоминают ключи от разных комнат в доме. Только хозяин ключа может войти в свою комнату, но гости могут зайти только туда, куда их пригласили!',
                isRight: true,
                align: 'flex-start',
            },
            {
                component: Paragraph,
                text: 'Три основных типа прав доступа включают:',
            },
            {
                component: List,
                list: ['Чтение <r> – позволяет просматривать содержимое файла или списка файлов в каталоге', 'Запись <w> – дает возможность изменять данные внутри файла либо добавлять новые элементы в каталог', 'Исполнение <x> – разрешает выполнение программы или переход внутрь каталога'],
            },
            {
                component: Paragraph,
                text: 'Эти три категории образуют основу управления безопасностью данных. Каждый файл или каталог имеет набор таких прав для трех категорий пользователей:',
            },
            {
                component: List,
                list: ['Владелец файла (или владелец каталога)', 'Группа владельцев', 'Все остальные пользователи системы'],
            },
            {
                component: Paragraph,
                text: 'Давай посмотрим пример того, как эти права отображаются в терминале. Например, если выполнить команду <ls -l>, то можно увидеть такую строку:',
            },
            {
                component: CodeBlock,
                text: '-rwxrw-r-- 1 user group 4096 Jan 1 12:00 file.txt',
            },
            {
                component: Paragraph,
                text: 'Здесь символы слева обозначают права доступа. Разберем их подробнее:',
            },
            {
                component: List,
                list: ['Первый символ указывает тип объекта: дефис <-> означает обычный файл, а <d> — директорию', 'Следующие девять символов разбиты на три группы по три буквы каждая:'],
            },
            {
                component: Paragraph,
                text: 'Первая группа относится к владельцу: здесь у владельца есть все права — чтение <r>, запись <w> и исполнение <x>.',
            },
            {
                component: Paragraph,
                text: 'Вторая группа — права группы: тут доступны только чтение и запись.',
            },
            {
                component: Paragraph,
                text: 'Третья группа — права всех остальных: им разрешено только читать файл.',
            },
            {
                component: Paragraph,
                text: 'Также важно отметить, что для директорий право исполнения работает немного иначе: оно позволяет переходить внутрь этой директории и выполнять поиск её содержимого.',
            },
            {
                component: Paragraph,
                text: 'Вот таблица, которая поможет тебе лучше понять распределение прав доступа:',
            },
            {
                component: CustomTable,
                data: [
                    ['Символ', 'Название', 'Что он делает'],
                    ['r', 'Чтение', 'Позволяет открывать и просматривать информацию'],
                    ['w', 'Запись', 'Дает возможность редактирования или удаления информации'],
                    ['x', 'Исполнение', 'Включает запуск программ или вход в каталог'],
                ],
            },
            {
                component: InfoBlock,
                text: 'В старых версиях операционной системы Unix, где изначально зародилась концепция прав доступа, каждое действие пользователя было строго регламентировано. Сегодня мы используем те же принципы в современных дистрибутивах Linux, включая Astra Linux, чтобы защитить наши данные от несанкционированного доступа.',
            },
            {
                component: Title,
                text: 'Владение файлами',
            },
            {
                component: Paragraph,
                text: 'Теперь давай разберемся, кто такой владелец файла и как управлять его правами доступа. Когда создаётся новый файл или папка, система автоматически назначает ему владельца. Обычно этим пользователем становится тот, кто создал объект. Однако иногда нужно изменить владельца или передать управление другому пользователю.',
            },
            {
                component: Paragraph,
                text: 'Владелец файла обладает максимальными полномочиями относительно этого объекта. Он может:',
            },
            {
                component: List,
                list: ['Читать содержимое файла', 'Редактировать его', 'Удалять', 'Менять права доступа для других пользователей'],
            },
            {
                component: Paragraph,
                text: 'Кроме того, владелец всегда контролирует группу, которой принадлежит файл.',
            },
            {
                component: Replica,
                image: cheers,
                text: 'Если ты стал владельцем файла, то можно делать с ним всё, что захочешь, словно этот файл теперь твой личный дневник!',
                isRight: false,
                align: 'flex-start',
            },
            {
                component: Paragraph,
                text: 'Снова обратимся к выводу команды <ls -l>. Вот пример вывода команды. Сразу за типом файла идёт имя пользователя-владельца ("user") и название группы ("group").',
            },
            {
                component: Paragraph,
                text: 'Иногда требуется сменить владельца файла. Для этого используется команда <chown>.',
            },
            {
                component: CodeBlock,
                text: 'chown [новое_имя_пользователя]:[новый_групповой_владелец] путь/к/файлу',
            },
            {
                component: Paragraph,
                text: 'Например, чтобы передать владение файлом от одного пользователя к другому, выполни следующую команду:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! sudo chown new_user:new_group /path/to/file.txt',
            },
            {
                component: Paragraph,
                text: 'После выполнения этой команды текущий пользователь станет новым владельцем файла, а указанный групповой владелец получит соответствующие полномочия.',
            },
            {
                component: InfoBlock,
                text: 'Важно помнить, что для смены владельца необходимо иметь административные привилегии, поэтому перед использованием команды часто приходится вводить пароль суперпользователя через sudo.',
            },
            {
                component: Paragraph,
                text: 'Правильное назначение владельца помогает обеспечить безопасность данных. Если файл оказался создан в неподходящей среде или группой с избыточными правами, любой другой пользователь мог бы получить нежелательный доступ к нему. Поэтому стоит внимательно следить за назначениями владельца при создании новых объектов.',
            },
            {
                component: Title,
                text: 'Группы пользователей',
            },
            {
                component: Paragraph,
                text: 'Продолжаем наше погружение в тему прав доступа и обсудим важный элемент системы безопасности — группы пользователей и как они помогают организовывать доступ к файлам и ресурсам в операционных системах вроде Astra Linux.',
            },
            {
                component: Paragraph,
                text: 'Представь себе ситуацию, когда несколько сотрудников компании должны совместно работать над одним проектом. Им всем нужен одинаковый уровень доступа к определенным документам и программам. Вместо того чтобы вручную настраивать права каждому сотруднику отдельно, проще объединить этих людей в одну группу и назначить общие права группе. Это значительно упрощает процесс управления доступом.',
            },
            {
                component: Paragraph,
                text: 'Когда создается новый файл, помимо владельца, ему присваивается определенная группа. Эта группа определяет, какие пользователи смогут взаимодействовать с объектом на уровне выше, чем "все остальные".',
            },
            {
                component: Paragraph,
                text: 'Чтобы проверить, какая группа присвоена конкретному файлу, используй команду <ls -l>. Например:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! -rwxrw-r-- 1 user developers 4096 Jan 1 12:00 project_file.txt',
            },
            {
                component: Paragraph,
                text: 'Здесь видно, что файл принадлежит группе "developers". Любой участник этой группы сможет открыть и редактировать данный файл, если права позволяют.',
            },
            {
                component: Paragraph,
                text: 'Если необходимо добавить нового сотрудника в существующую группу, воспользуйся командой <usermod>:',
            },
            {
                component: CodeBlock,
                text: 'sudo usermod -aG <название_группы> <имя_пользователя>',
            },
            {
                component: Paragraph,
                text: 'Эта команда добавит указанного пользователя в выбранную группу. Важно заметить флаг <-aG>: он гарантирует, что другие группы пользователя останутся нетронутыми.',
            },
            {
                component: Paragraph,
                text: 'У каждой группы также есть свои права доступа, аналогичные правам владельца. Рассмотрим пример:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! drwxr-x--- 2 root developers 4096 Jan 1 12:00 shared_folder/',
            },
            {
                component: Paragraph,
                text: 'Здесь:',
            },
            {
                component: List,
                list: ['Директория доступна для записи и чтения владельцу ("root")', 'Пользователи группы "developers" могут заходить в нее и искать ее содержимое', 'Остальные пользователи вообще лишены доступа'],
            },
            {
                component: Paragraph,
                text: 'Такой подход идеально подходит для организации совместного доступа между коллегами.',
            },
            {
                component: InfoBlock,
                text: 'Администратор системы может создавать новые группы, удалять старые и контролировать членство в них. Это позволяет гибко распределять ресурсы среди различных отделов или проектов.',
            },
            {
                component: Title,
                text: 'Изменение прав доступа',
            },
            {
                component: Paragraph,
                text: 'Мы подошли к заключительной части нашего обсуждения — команде <chmod>, которая позволяет непосредственно изменять разрешения на файлы и папки. Этот инструмент чрезвычайно важен для любого системного администратора, поскольку даёт полный контроль над уровнем доступа пользователей к различным объектам в системе.',
            },
            {
                component: Paragraph,
                text: 'Команда <chmod> предоставляет два способа задания прав доступа: символьный и числовой. Мы рассмотрим оба метода.',
            },
            {
                component: Paragraph,
                text: 'Символьная форма позволяет указывать конкретные изменения в правах, например, добавив или удалив определенные разрешения. Формат выглядит следующим образом:',
            },
            {
                component: CodeBlock,
                text: 'chmod [who][operator][permission] путь/к/объекту',
            },
            {
                component: Paragraph,
                text: 'Где:',
            },
            {
                component: List,
                list: ['<[who]> — указатель на категорию пользователей (u = владелец, g = группа, o = прочие, a = все)', '<[operator]> — оператор действий (+ = добавить разрешение, - = удалить разрешение, = = установить конкретные разрешения)', '<[permission]> — само разрешение (r = чтение, w = запись, x = исполнение)'],
            },
            {
                component: Paragraph,
                text: 'Пример использования:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! chmod u+w,g+r,o-rwx somefile.txt',
            },
            {
                component: Paragraph,
                text: 'Этот код добавляет право записи владельцу (<u+w>), устанавливает право чтения для группы (<g+r>) и полностью запрещает доступ остальным пользователям (<o-rwx>).',
            },
            {
                component: Paragraph,
                text: 'Второй способ работы с <chmod> использует восьмеричные числа для представления прав доступа. Каждому типу прав соответствует число:',
            },
            {
                component: List,
                list: ['4 — чтение <r>', '2 — запись <w>', '1 — исполнение <x>'],
            },
            {
                component: Paragraph,
                text: 'Суммируя эти значения, получаем различные комбинации прав. Например:',
            },
            {
                component: List,
                list: ['7 (4+2+1) — полное разрешение (чтение + запись + исполнение)', '6 (4+2) — чтение и запись', '4 — только чтение'],
            },
            {
                component: Paragraph,
                text: 'Применение числовых значений происходит так:',
            },
            {
                component: CodeBlock,
                text: 'chmod 755 directory_name',
            },
            {
                component: Paragraph,
                text: 'Здесь:',
            },
            {
                component: List,
                list: ['7 — полные права для владельца', '5 (4+1) — чтение и исполнение для группы и прочих пользователей'],
            },
            {
                component: Paragraph,
                text: 'Рассмотрим еще пару примеров:',
            },
            {
                component: Paragraph,
                text: '1. Установим права на создание исполняемого скрипта:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! chmod +x script.sh',
            },
            {
                component: Paragraph,
                text: '2. Сделаем файл доступным только для чтения всеми пользователями:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! chmod 444 textfile.txt',
            },
            {
                component: Paragraph,
                text: '3. Полностью запретим доступ ко всему файлу:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! chmod 000 sensitive_data.bin',
            },
            {
                component: Paragraph,
                text: 'Используя эту команду, ты сможешь легко адаптировать систему под свои нужды, предоставляя разные уровни доступа разным категориям пользователей. Будь осторожны: неправильно настроенные права могут сделать важные файлы уязвимыми или недоступными даже тебе самому!',
            },
            {
                component: Paragraph,
                text: '',
            },
        ],
        tests: [
            {
                name: "#1    Какая команда используется для добавления пользователя в определенную группу?",
                answers: [
                    "sudo adduser",
                    "sudo chgrp",
                    "sudo usermod -aG <название_группы> <имя_пользователя>",
                    "sudo chown"
                ],
                correct: "C",
            },
            {
                name: "#2    Что произойдет, если использовать команду chmod 700 file.txt?",
                answers: [
                    "Только владелец будет иметь полный доступ к файлу",
                    "Все пользователи получат полный доступ к файлу",
                    "Файл будет доступен только для чтения всеми пользователями",
                    "Будет установлен атрибут архивации"
                ],
                correct: "A",
            },
            {
                name: "#3    Какие права получает пользователь, если к файлу применяется команда chmod u+x filename?",
                answers: [
                    "Возможность только читать файл",
                    "Возможность записывать в файл",
                    "Возможность исполнять файл",
                    "Нет изменений в правах доступа"
                ],
                correct: "C",
            },
            {
                name: "#4    Какой символ в выводе команды ls -l указывает на то, что объект является директорией?",
                answers: [
                    "d",
                    "-",
                    "l",
                    "s"
                ],
                correct: "A",
            },
            {
                name: "#5    Если файл имеет права доступа drwxr-x---, кто из следующих пользователей может изменять содержимое этого файла?",
                answers: [
                    "Все пользователи",
                    "Только владельцы группы",
                    "Только владелец файла",
                    "Никто не может изменять файл"
                ],
                correct: "C",
            },
        ],
        conclusion: [
            {
                component: Title,
                text: 'Итого',
            },
            {
                component: Paragraph,
                text: 'Подведём итоги. Мы познакомились с основами прав доступа в Astra Linux: узнали, как устроено владение файлами, поняли важность групп пользователей и научились изменять права с помощью команды <chmod>. Эти знания помогут тебе эффективнее управлять ресурсами и обеспечивать безопасность данных. Но впереди ещё много интересного!',
            },
            {
                component: Paragraph,
                text: '',
            },
        ],
    },
    {
        chapter: 'Поиск файлов и информации',
        content: [
            {
                component: Title,
                text: 'Поиск файлов по имени',
            },
            {
                component: Paragraph,
                text: 'Иногда кажется, что нужный файл просто испарился. Но не спеши паниковать — в Linux, в том числе и в Astra Linux, есть отличные инструменты, которые помогут его найти. Один из таких инструментов — команда <find>. С её помощью можно отыскать любой файл по имени, дате изменения, размеру и другим критериям. Сегодня разберёмся с поиском по названию.',
            },
            {
                component: Paragraph,
                text: 'Команда <find> умеет обходить каталоги, начиная с заданной точки, и проверять каждый файл и папку на соответствие заданным условиям. Самый простой способ её использования выглядит так:',
            },
            {
                component: CodeBlock,
                text: 'find <путь> -name <имя_файла>',
            },
            {
                component: Paragraph,
                text: 'Допустим, ты хочешь найти файл с точным именем "config.txt" в домашнем каталоге. Тогда команда будет такой:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find ~/ -name config.txt',
            },
            {
                component: Paragraph,
                text: 'Важно понимать: поиск будет учитывать точное совпадение имени. Если файл называется "Config.txt", такая команда его не найдёт. Для того чтобы искать без учёта регистра, используется опция <-iname>:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find ~/ -iname config.txt',
            },
            {
                component: Paragraph,
                text: 'Такая команда найдёт и "config.txt", и "Config.TXT", и даже "CoNfIg.TxT."',
            },
            {
                component: Paragraph,
                text: 'Теперь представим, что ты помнишь только часть имени файла. Например, файл содержал в названии слово "log". В этом случае тебе пригодится символ звёздочки <*>, который обозначает любое количество любых символов:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find /var/log -name "*log*"',
            },
            {
                component: Paragraph,
                text: 'Эта команда найдёт все файлы и папки в каталоге </var/log>, в названии которых встречается подстрока "log". Например:',
            },
            {
                component: CodeBlock,
                text: '/var/log/syslog\n/var/log/auth.log\n/var/log/mylogfile.txt',
            },
            {
                component: Paragraph,
                text: 'Хочешь искать только среди файлов, исключая каталоги? Добавим флаг <-type f>:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find /home/student -type f -name "*.sh"',
            },
            {
                component: Paragraph,
                text: 'Теперь будут найдены только файлы-скрипты, заканчивающиеся на ".sh".',
            },
            {
                component: InfoBlock,
                text: 'Если ты не хочешь видеть в выводе ошибки доступа (например, от системных директорий), просто направь их в "никуда":\nfind / -name "config.txt" 2>/dev/null',
            },
            {
                component: Paragraph,
                text: 'Также можно искать по нескольким именам. Например, если мы хотим найти "file1.txt" и "file2.txt" в каталоге </tmp> введем:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find /tmp \( -name "file1.txt" -o -name "file2.txt" \)',
            },
            {
                component: InfoBlock,
                text: 'Обрати внимание на скобки и пробелы:\ncкобки нужно экранировать обратным слэшем \, а флаг -o означает "ИЛИ".',
            },
            {
                component: Paragraph,
                text: 'Потренируйся находить файлы по их названию — с учётом регистра, масками и указанием нужного каталога. Это навык, который пригодится каждый день, особенно когда файлов становится всё больше.',
            },
            {
                component: Title,
                text: 'Поиск текста внутри файлов',
            },
            {
                component: Paragraph,
                text: 'Ты когда-нибудь пытался вспомнить, в каком именно файле писал важное примечание вроде "Не удалять!" или "Пароль: 1234"? В мире Linux есть команда, которая справляется с такими задачами на ура — это <grep>.',
            },
            {
                component: Paragraph,
                text: 'Команда <grep> ищет строки, содержащие указанный текст, внутри файлов. Работает она быстро и очень гибко, особенно когда знаешь, как с ней обращаться. Давай разбираться.',
            },
            {
                component: Paragraph,
                text: 'Самый простой пример — поиск слова внутри одного файла:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! grep "важно" заметки.txt',
            },
            {
                component: Paragraph,
                text: 'Если в файле "заметки.txt" есть строка с этим словом, <grep> её выведет:',
            },
            {
                component: CodeBlock,
                text: 'Очень важно не забыть сделать резервную копию.',
            },
            {
                component: Paragraph,
                text: 'Теперь усложним задачу. Хочешь найти текст сразу во всех файлах текущей директории и её подкаталогов? Используй флаг <-r>:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! grep -r "пароль" .\n./docs/settings.txt:пароль: 1234\n./log/errors.log:Неверный пароль при входе',
            },
            {
                component: Paragraph,
                text: 'Чтобы не зависеть от регистра букв (например, чтобы "Пароль" и "пароль" тоже находились), добавь флаг <-i>:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! grep -ri "пароль" .',
            },
            {
                component: Paragraph,
                text: 'А если ты хочешь не только увидеть совпавшие строки, но и узнать их номера, добавь <-n>:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! grep -n "TODO" скрипт.sh',
            },
            {
                component: Paragraph,
                text: 'Для расширенного поиска можно использовать регулярные выражения. Например, найди строки, в которых есть слово, начинающееся с "ошиб":',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! grep -E "ошиб.*" журнал.log',
            },
            {
                component: Paragraph,
                text: 'Флаг <-E> включает поддержку расширенных регулярных выражений. Тут <.*> означает любые символы после "ошиб".',
            },
            {
                component: Replica,
                image: like,
                text: 'Если ты ищешь слово в тысячах файлов, не забывай — grep знает больше, чем ты думаешь. Просто спроси красиво!',
                isRight: false,
                align: 'flex-start',
            },
            {
                component: Paragraph,
                text: '<grep> — мощный союзник в поиске информации. Он не просто находит строки — он находит смысл в бесконечных логах и заметках. И если ты освоишь его, то больше никогда не потеряешь важную строчку в коде, конфиге или просто в старом текстовом файле.',
            },
            {
                component: Title,
                text: 'Фильтрация результатов поиска',
            },
            {
                component: Paragraph,
                text: 'Иногда ты знаешь, что ищешь, но слишком много совпадений мешают быстро найти нужное. Представь, что ты зовёшь друга в толпе, и на зов откликаются сто человек. Вот тут-то и нужна фильтрация! К счастью, команда <find> умеет фильтровать файлы по множеству критериев.',
            },
            {
                component: Paragraph,
                text: 'Начнём с фильтрации по типу. Хочешь искать только файлы? Как мы уже говорили, добавь <-type f>. Только каталоги? Используй <-type d>.',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find /home/student -type f -name "*.txt"',
            },
            {
                component: Paragraph,
                text: 'Дальше — размер. Допустим, тебе нужен файл больше 10 мегабайт:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find / -size +10M',
            },
            {
                component: Paragraph,
                text: 'А если наоборот — меньше 500 килобайт:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find /home/student -size -500k',
            },
            {
                component: Paragraph,
                text: 'Вот краткая таблица единиц:',
            },
            {
                component: CustomTable,
                data: [
                    ['Обозначение', 'Размер'],
                    ['c', 'байты'],
                    ['k', 'килобайты'],
                    ['M', 'мегабайты'],
                    ['G', 'гигабайты'],
                ],
            },
            {
                component: Paragraph,
                text: 'Следующий фильтр — дата изменения. Хочешь найти файлы, которые редактировались за последние 2 дня?',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find ~/projects -mtime -2',
            },
            {
                component: Paragraph,
                text: 'А если наоборот — давно забытые артефакты? Например, не тронутые 30 дней:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find ~/ -mtime +30',
            },
            {
                component: Paragraph,
                text: 'Можно фильтровать и по владельцу. Допустим, ты хочешь найти все файлы, созданные пользователем "ivan":',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find / -user ivan',
            },
            {
                component: Paragraph,
                text: 'А что, если тебе нужно найти исполняемые файлы? Проверь разрешения с помощью <-perm>. Например, все файлы с правом на запуск:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find /usr/bin -type f -perm /111',
            },
            {
                component: Paragraph,
                text: 'И, наконец, фильтрация по имени и дате одновременно:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find /var/log -name "*.log" -mtime -7',
            },
            {
                component: Paragraph,
                text: 'Так ты найдёшь все лог-файлы, изменённые за последнюю неделю. Удобно, если нужно быстро проверить последние события в системе.',
            },
            {
                component: Replica,
                image: smile,
                text: 'Фильтруй с умом: в файлах, как и в жизни, меньше — значит точнее!',
                isRight: true,
                align: 'flex-start',
            },
            {
                component: Paragraph,
                text: 'Фильтрация — это как наводка телескопа на нужную звезду. Благодаря комбинациям критериев <find> помогает не просто искать, а находить именно то, что нужно.',
            },
            {
                component: Title,
                text: 'Примеры поиска',
            },
            {
                component: Paragraph,
                text: 'Теория — это здорово, но в реальной жизни файлы теряются, логи путаются, а скрипты улетают в неизвестные глубины файловой системы. Давай посмотрим, как можно применить команды <find> и <grep> в живых ситуациях.',
            },
            {
                component: Paragraph,
                text: '',
            },
            {
                component: Paragraph,
                text: 'Пример 1. Найти все .sh-скрипты в домашней директории',
            },
            {
                component: Paragraph,
                text: 'Ты хочешь проверить, где у тебя хранятся все скрипты. Выполни:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find ~ -type f -name "*.sh"',
            },
            {
                component: Paragraph,
                text: '',
            },
            {
                component: Paragraph,
                text: 'Пример 2. Очистить место, найдя старые большие файлы',
            },
            {
                component: Paragraph,
                text: 'Система жалуется на нехватку места. Найдём всё, что весит больше 100 МБ и не трогалось месяц:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find /home/student -size +100M -mtime +30',
            },
            {
                component: Paragraph,
                text: '',
            },
            {
                component: Paragraph,
                text: 'Пример 3. Найти конфигурации с упоминанием «proxy»',
            },
            {
                component: Paragraph,
                text: 'Ты не помнишь, в каком конфиге была строчка с прокси. Запусти:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! grep -ri "proxy" /etc',
            },
            {
                component: Paragraph,
                text: '',
            },
            {
                component: Paragraph,
                text: 'Пример 4. Вытащить ошибки из системного журнала',
            },
            {
                component: Paragraph,
                text: 'Ты изучаешь файл "syslog" и хочешь увидеть только строки с ошибками:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! grep "ERROR" /var/log/syslog',
            },
            {
                component: Paragraph,
                text: 'Или, если хочешь убрать все DEBUG-сообщения:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! grep -v "DEBUG" /var/log/syslog',
            },
            {
                component: Paragraph,
                text: '',
            },
            {
                component: Paragraph,
                text: 'Пример 5. Найти все пустые каталоги',
            },
            {
                component: Paragraph,
                text: 'Иногда система засоряется пустыми папками. Ловим их так:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! find /home/student -type d -empty',
            },
            {
                component: Paragraph,
                text: 'Каждый из этих примеров — как мини-головоломка. Но теперь у тебя есть инструменты, чтобы их решать. Пробуй, адаптируй, и пусть ни один нужный файл не ускользнёт от тебя!',
            },
            {
                component: Paragraph,
                text: '',
            },
        ],
        tests: [
            {
                name: "#1    Какая из следующих команд найдёт все файлы с расширением .log, которые были изменены за последние 7 дней и находятся только в директории /var/log, но не в её подкаталогах?",
                answers: [
                    'find /var/log -type f -name " *.log" -mtime -7',
                    'find /var/log -name "*.log" -mtime -7 -maxdepth 0 ',
                    'find /var/log -maxdepth 1 -type f -name "*.log" -mtime -7  ',
                    'grep -r -m7 "*.log" /var/log'
                ],
                correct: "C",
            },
            {
                name: '#2    Какой результат даст команда grep -rin " ^\s*#TODO" ~/projects/?',
                answers: [
                    "Найдёт все строки с TODO, начинающиеся с любого количества пробелов без учёта регистра",
                    "Найдёт строки, содержащие символ # и слово TODO в любом месте строки",
                    "Найдёт строки, начинающиеся с #TODO, без пробелов в начале",
                    "Найдёт только те строки, где `#TODO` написано без пробелов и только в верхнем регистре"
                ],
                correct: "A",
            },
            {
                name: "#3    Какая команда отыщет все исполняемые файлы в каталоге /usr/local/bin, независимо от их владельца или группы?",
                answers: [
                    "find /usr/local/bin -type f -perm -111",
                    "find /usr/local/bin -perm /111 -type f",
                    "find /usr/local/bin -executable -type f",
                    "Все вышеперечисленные"
                ],
                correct: "D",
            },
            {
                name: '#4    Что произойдёт при выполнении команды "find . -type f -name "*.conf" -exec grep -l "Listen" {} +"?',
                answers: [
                    'Выведет список строк, содержащих слово "Listen" во всех .conf файлах',
                    'Заменит все строки "Listen" на пустоту в файлах .conf',
                    'Выведет только имена файлов .conf, в которых встречается "Listen"',
                    "Откроет найденные .conf файлы в текстовом редакторе"
                ],
                correct: "C",
            },
            {
                name: "#5    Какой командой можно исключить из поиска все пути, содержащие каталог backup, при поиске файлов .txt?",
                answers: [
                    'find . -name "*.txt" ! -path "*backup*"',
                    'find . -name "*.txt" -not -name "*backup*"',
                    'find . -type f -name "*.txt" -not -exec grep "backup" {} \;',
                    'find . -type f -name "*.txt" -exclude "backup"'
                ],
                correct: "A",
            },
        ],
        conclusion: [
            {
                component: Title,
                text: 'Итого',
            },
            {
                component: Paragraph,
                text: 'Мы познакомились с командами <find> и <grep>, узнали, как находить файлы по имени, искать текст внутри документов, фильтровать результаты и применять поиск на практике. Эти инструменты — настоящие помощники в работе администратора: они позволяют быстро ориентироваться в огромных массивах данных, находить нужную информацию и поддерживать порядок в системе.\nЧем лучше ты освоишь их, тем увереннее будешь себя чувствовать в любой ситуации — будь то устранение проблем, анализ логов или просто поиск потерянного файла.',
            },
            {
                component: Paragraph,
                text: '',
            },
        ],
    },
    {
        chapter: 'Символические ссылки',
        content: [
            {
                component: Title,
                text: 'Символические ссылки',
            },
            {
                component: Paragraph,
                text: 'Иногда один и тот же файл может быть нужен в разных местах — например, твой скрипт "backup.sh" используется сразу в трёх проектах. Вместо того чтобы копировать файл в каждую папку, можно создать символическую ссылку — лёгкий и элегантный способ сослаться на исходный файл.',
            },
            {
                component: Paragraph,
                text: 'Символическая ссылка (или симлинк) — это особый тип файла, который указывает на другой файл или каталог. Представь, что это ярлык, как в графической среде: сам по себе он не содержит данных, а просто перенаправляет к оригиналу.',
            },
            {
                component: Paragraph,
                text: 'Допустим, у тебя есть файл </home/student/scripts/backup.sh>. А ты хочешь обращаться к нему из другой директории, например, </home/student/project-a/run-backup.sh>. Вместо копирования можно создать ссылку — и файл будет доступен в двух местах, хотя физически существует только в одном.',
            },
            {
                component: InfoBlock,
                text: 'Важное отличие: если ты удалишь оригинал, символическая ссылка «сломается» — она станет вести в никуда. Это отличие от жесткой ссылки, которая, наоборот, сохраняет связь с данными даже при удалении исходного имени файла.',
            },
            {
                component: Paragraph,
                text: 'Можно увидеть, что файл является символической ссылкой, с помощью команды <ls -l>. Например:',
            },
            {
                component: CodeBlock,
                text: 'lrwxrwxrwx 1 student student 24 Apr 20 13:30 run-backup.sh -> /home/student/scripts/backup.sh',
            },
            {
                component: Paragraph,
                text: 'Здесь <l> в начале строки указывает, что это ссылка, а "->" показывает, куда она указывает.',
            },
            {
                component: Paragraph,
                text: 'Символические ссылки — это отличный способ сократить дублирование и упростить структуру каталогов, особенно в больших проектах или при настройке конфигураций.',
            },
            {
                component: Title,
                text: 'Создание ссылок',
            },
            {
                component: Paragraph,
                text: 'Создавать символические ссылки в Linux — проще простого. Всё делается одной командой:',
            },
            {
                component: CodeBlock,
                text: 'ln -s <оригинал> <ссылка>',
            },
            {
                component: Paragraph,
                text: 'Допустим, у тебя есть файл </home/student/scripts/backup.sh>. А ты хочешь, чтобы в папке "project-a" появился ярлык на него под именем <run-backup.sh>. Выполняй:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! ln -s /home/student/scripts/backup.sh /home/student/project-a/run-backup.sh',
            },
            {
                component: Paragraph,
                text: 'После выполнения в папке "project-a" появится новый файл <run-backup.sh>, который ведёт к оригинальному <backup.sh>.',
            },
            {
                component: Paragraph,
                text: 'Можно создавать ссылки и на каталоги. Например, если ты часто работаешь с папкой "/var/log/apache2", а она далеко, сделай ссылку в домашнем каталоге:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! ln -s /var/log/apache2 ~/apache-logs',
            },
            {
                component: InfoBlock,
                text: 'Обрати внимание: -s означает symbolic. Если его не указать, будет создана жёсткая ссылка, которая работает по-другому (и не поддерживается для каталогов).',
            },
            {
                component: Title,
                text: 'Применение',
            },
            {
                component: Paragraph,
                text: 'Символические ссылки — это не просто удобство, а настоящая магия управления файлами. Они особенно полезны, когда тебе нужно иметь доступ к одному и тому же ресурсу из разных мест, но без копирования или дублирования.',
            },
            {
                component: Paragraph,
                text: 'Вот где симлинки особенно выручают:',
            },
            {
                component: Paragraph,
                text: '',
            },
            {
                component: Paragraph,
                text: '1. Упрощение доступа к файлам и папкам',
            },
            {
                component: Paragraph,
                text: 'У тебя есть длиннющий путь к конфигурационной папке, например, </etc/nginx/sites-available/my-super-long-name.conf>. А ты хочешь открывать её быстрее. Создай короткую ссылку:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! ln -s /etc/nginx/sites-available/my-super-long-name.conf ~/nginx.conf',
            },
            {
                component: Paragraph,
                text: 'Теперь файл всегда под рукой — открывай из домашней директории.',
            },
            {
                component: Paragraph,
                text: '',
            },
            {
                component: Paragraph,
                text: '2. Обновляемая версия программы',
            },
            {
                component: Paragraph,
                text: 'Разработчики часто используют симлинки, чтобы переключаться между разными версиями программ. Например, </usr/local/bin/app> → </opt/app-v2.1.0/app>. Когда выходит новая версия, они просто меняют ссылку:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! ln -sfn /opt/app-v2.2.0/app /usr/local/bin/app',
            },
            {
                component: Paragraph,
                text: 'И вся система начинает использовать новую версию — без переустановки и изменения путей.',
            },
            {
                component: Paragraph,
                text: '',
            },
            {
                component: Paragraph,
                text: '3. Организация каталогов и связей между проектами',
            },
            {
                component: Paragraph,
                text: 'Допустим, в нескольких проектах используется одна и та же библиотека или папка с ресурсами. Вместо копирования можно сделать символическую ссылку на общую директорию:',
            },
            {
                component: CodeBlock,
                text: '!robocat@astra:~$! ln -s ~/shared/assets ./project-a/assets',
            },
            {
                component: Paragraph,
                text: 'Теперь любые изменения в <~/shared/assets> сразу отразятся в проекте.',
            },
            {
                component: Paragraph,
                text: '',
            },
            {
                component: Paragraph,
                text: 'И главное преимущество:',
            },
            {
                component: Paragraph,
                text: 'Ты можешь изменить или обновить оригинал, а все симлинки, указывающие на него, автоматически "увидят" эти изменения. Это особенно ценно при работе с конфигурациями, библиотеками и скриптами.',
            },
            {
                component: Replica,
                image: smile,
                text: 'Символическая ссылка — это способ быть в нескольких местах одновременно. Ну, почти как магия…',
                isRight: false,
                align: 'flex-start',
            },
        ],
    },
]